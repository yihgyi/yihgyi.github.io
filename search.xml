<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>redis高级篇</title>
      <link href="/2025/11/14/Redis%E9%AB%98%E7%BA%A7%E7%AF%87/"/>
      <url>/2025/11/14/Redis%E9%AB%98%E7%BA%A7%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis高级篇"><a href="#Redis高级篇" class="headerlink" title="Redis高级篇"></a>Redis高级篇</h1><h2 id="单节点部署Redis的问题"><a href="#单节点部署Redis的问题" class="headerlink" title="单节点部署Redis的问题"></a>单节点部署Redis的问题</h2><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251014210144846.png" alt="image-20251014210144846"></p><p>数据丢失:Redis是基于内存存储,服务重启可能丢失数据,需要做<strong>持久化</strong>,讲内存数据写入磁盘</p><p>并发能力:在高并发情况下,单个节点redis扛不住(百万并发),主从集群,实现<strong>负载均衡</strong>的多个从节点,并且读写分离,读写之间没有影响从而并发能力更强,主挂了,从顶上,从而使系统具有高可用性</p><p>故障恢复:集群部署还能实现先用还正常的,一个挂了就是真的挂了(需要变运行变修复的效果才能稳定运行) 靠哨兵机制, 检测<strong>健康状态</strong>并且自动恢复</p><p>基于内存: 内存存储容量没有磁盘高,单节点内存有限,主从集群其实主从数据是一样的所以内存上限还是单个节点的上限,为了解决这个问题可以使用Elastic Search的分片存储 把数据分片保存到不同节点上 这样就可以存储更多数据了,搭建分片集群,利用<strong>插槽机制</strong>实现<strong>动态扩容</strong>(理论上存储能力没有上限)</p><h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251014211533592.png" alt="image-20251014211533592"></p><p>在某一时刻把Redis的数据文件备份一份出来写到当前运行redis的磁盘目录中</p><p>但是Redis服务器是单线程的,执行save时候会阻塞所有命令,而磁盘IO比较耗时,当redis数据比较多的时候,就会影响服务器的性能</p><p>所以save操作一般是redis节点将要关闭前执行好一些</p><p>所以推荐使用bgsave,可以开启一个子进程异步执行RDB</p><p>停机时候会自动保存到redis当前所在运行目录</p><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251014212033476.png" alt="image-20251014212033476"></p><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251014212052664.png" alt="image-20251014212052664"></p><p>再次启动redis时候,数据就会自动恢复(默认就有持久化)</p><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251014212851345.png" alt="image-20251014212851345">  </p><p>停机时候执行(但是宕机就不好说了)</p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251014212334479.png" alt="image-20251014212334479"></p><p>自动触发RDB 900s有一个key被修改 开启一个子线程来做RDB 300s 10个 60s 1w个</p><p>RDB 不设置压缩 redis数据在内存中占多少,那么存到磁盘中就占多少 压缩的话用到cpu资源 cpu资源充足建议开启压缩</p><p>RDB的文件名默认是dump.rdb 默认保存在redis当前运行的路径中</p><p>测试触发时机</p><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251014212951290.png" alt="image-20251014212951290"></p><h4 id="RDB的实现原理"><a href="#RDB的实现原理" class="headerlink" title="RDB的实现原理"></a>RDB的实现原理</h4><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251014233455498.png" alt="image-20251014233455498"></p><p>RDB 使用子进程来做备份写入磁盘时,</p><p>需要<strong>子进程得到当时内存中的数据,而这个操作也需要时间,会阻塞主进程</strong></p><p>所以为了解决这个问题 RDB方法采取的是<strong>fork 主进程使用的页表</strong></p><p>(进程不能直接访问物理内存,由操作系统维护页表,页表上由内存的映射,主进程在页表上进行操作,操作系统再操作内存)</p><p>这样子进程就拿到了主进程使用的页表就可以实现<strong>共享内存</strong>了</p><p>但是考虑到主进程此后还会进行读写操作 就会和子进程的读操作发生<strong>读写冲突</strong></p><p>所以RDB采取的方案是 copy-on-write  父子进程共享内存对应在页表中的每一项都是标记只读(Read-only) 当主进程进行写操作时,操作系统将该物理内存的数据进行拷贝得到副本,此时主进程页表项上映射到内存副本的地址,之后主进程读该数据也会读副本</p><p>在副本上进行读写操作</p><p>这里就会出现一个极端情况,如果在子进程写入磁盘的过程中,主进程把所有数据都更新了,那么就会出现全部数据都有副本,原本的占用的物理内存就会翻倍 所以设计时候内存应该有预留防止出现这种情况</p><p>子进程写的时候是写入一个新的rdb文件 而不是在原来的rdb文件上修改,然后后面替换掉使用的rdb文件</p><h4 id="禁用RDB"><a href="#禁用RDB" class="headerlink" title="禁用RDB"></a>禁用RDB</h4><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251015104939509.png" alt="image-20251015104939509"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251015000816747.png" alt="image-20251015000816747"></p><p>优点</p><p>开启子进程不会影响主进程 对主进程资源占用低</p><p>快速加载 RDB快照文件是压缩的二进制文件 适合备份和灾难恢复</p><p>缺点</p><p>比如说30s才写一次到磁盘的话,那中间如果宕机,内存数据就没了</p><p>如果设置写时间较短的话,会增加系统的负担,因为开启子进程在fork页表,压缩,写入磁盘都耗时间且占用资源</p><h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251015101159695.png" alt="image-20251015101159695"></p><p>往一个文件中追加,记录每一个操作的命令,可以当作是命令日志文件 $ 表示命令的长度</p><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251015105149790.png" alt="image-20251015105149790"></p><p>每次恢复时从头执行一遍这个文件中的命令</p><p>在redis中默认关闭</p><p>​开启修改配置文件</p><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251015101710694.png" alt="image-20251015101710694"></p><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251015102140832.png" alt="image-20251015102140832"></p><h4 id="刷盘策略"><a href="#刷盘策略" class="headerlink" title="刷盘策略"></a>刷盘策略</h4><p>AOF的频率有三种,always表示redis每执行一条命令就同步将该命令追加到AOP文件中,都是由主进程来执行</p><p>everysec对磁盘读写做了优化,主进程将命令日志存放到内存中的缓冲区,然后每秒钟开启子线程再把缓冲区数据写到磁盘(可能丢失一秒的数据)</p><p>no的话是主进程只把命令日志放到缓冲区, 缓冲区写到磁盘的操作由操作系统来处理 只是写到了内存中,可靠性不能保证</p><p>关闭RDB只开启AOF</p><p>默认使用的就是 everysec</p><p>然后写入当前运行目录 </p><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251015105251843.png" alt="image-20251015105251843"></p><p>停掉的话会对AOF数据再次检查</p><p>启动时候对AOF数据进行加载</p><p>AOF是个命令都记录,操作日志,就会使这个AOF内存占用要大,而且有的命令只有最后一次操作有意义(更新到最后一次 前面的都没用)但还是在恢复时都执行了</p><p>为了解决这个问题</p><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251015105635913.png" alt="image-20251015105635913"></p><p>使用bgrewriteof对aof文件进行重写 开启独立进程执行</p><p>子进程在重写 然后主进程把新东西放到一个重写缓冲区 然后重写完就追加到后面去最后替换掉原AOF文件 </p><p>同时主进程把新操作追加进原AOF 防止重写时后出现问题</p><h4 id="触发AOF文件重写"><a href="#触发AOF文件重写" class="headerlink" title="触发AOF文件重写"></a>触发AOF文件重写</h4><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251015105917954.png" alt="image-20251015105917954"></p><p>比如之前时10 这次变成了21 增长超过了1倍</p><p>或者说文件大小达到了多少</p><h3 id="RDB和AOF的区别"><a href="#RDB和AOF的区别" class="headerlink" title="RDB和AOF的区别?"></a>RDB和AOF的区别?</h3><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251015125339730.png" alt="image-20251015125339730"></p><p>因为RDB是保存数据,而AOF是记录操作日志,直接加载数据会比执行操作要快一些,所以宕机恢复速度速度是RDB快一些</p><p>fork 压缩 子进程IO占用系统资源 aof开启子线程io</p><p>一般来说RDB+AOF混合使用 </p><p>数据完整性 AOF相对完整一些,默认的刷盘策略只会丢失1s內的 所以恢复优先级是AOF高一些</p><p>现在RDB+AOF混合持久化</p><p>触发重写时候,RDB生成最新快照加到AOF头,然后之后的操作继续追加到AOF后面,恢复时候用RDB,然后再把后面的操作执行</p><h2 id="主从架构"><a href="#主从架构" class="headerlink" title="主从架构"></a>主从架构</h2><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251015141610171.png" alt="image-20251015141610171"></p><p>从节点两个名字</p><p>业务中一般读操作比较多,所以让从节点分担读的压力,写写到主节点上,并且主节点和从节点之间实现数据同步</p><p>模拟主从架构,准备阶段</p><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251015144201555.png" alt="image-20251015144201555"></p><p>RDB打开 AOF关闭</p><p>ip和配置文件配置好以后</p><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251015152413257.png" alt="image-20251015152413257"></p><p>需要设置主从关系</p><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251015152448815.png" alt="image-20251015152448815"></p><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251015152652296.png" alt="image-20251015152652296"></p><p>主从读写分离效果</p><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251015152828775.png" alt="image-20251015152828775"></p><p>从节点只读 写操作只在主节点上允许</p><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251015152950991.png" alt="image-20251015152950991"></p><h2 id="主从数据同步原理"><a href="#主从数据同步原理" class="headerlink" title="主从数据同步原理"></a>主从数据同步原理</h2><h3 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h3><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251015160637933.png" alt="image-20251015160637933"></p><p>确定主从关系,判断是否第一次来,</p><p>是就使用全量同步,版本信息用来做版本控制</p><p>主节点把内存的所有数据发送,就用到bgsave保存<strong>RDB快照</strong>把RDB文件(先写入主节点磁盘)发送给从节点来执行(发送文件这一步比较占用资源,因为是所有数据)</p><p>主节点写RDB时<strong>处理请求执行的命令</strong>写入到缓冲区中,到时候还会把这里的命令发送给从节点来执行</p><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251015161953438.png" alt="image-20251015161953438"></p><p>如何确定是否第一次来?</p><p>主节点的数据集有自己的replid 同步以后就给从节点也带上这个id </p><p>并且有偏移量, 从节点偏移量小于等于主节点 等于的话就是完全一致</p><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251015162417975.png" alt="image-20251015162417975"></p><p>判断是否是第一次 则需要看replid</p><p>每个从节点在成为从节点前,自己也有replid(自己当作是主节点和offset)</p><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251015162545233.png" alt="image-20251015162545233"></p><p>从节点把自己的replid和offset发送过来,主节点判断replid是否一致,不一致才是第一次,然后返回主节点的replid和offset</p><p>基于offset做增量同步</p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>从节点发送请求</p><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251015163617378.png" alt="image-20251015163617378"></p><p>请求局部同步,发送replid</p><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251015163800447.png" alt="image-20251015163800447"></p><p>replid不匹配 不允许做增量同步 要做全量同步</p><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251015163859960.png" alt="image-20251015163859960"></p><p>从节点做全量同步</p><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251015164338799.png" alt="image-20251015164338799"></p><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251015164436343.png" alt="image-20251015164436343"></p><h3 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h3><p>时机:子节点重启时</p><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251015210237114.png" alt="image-20251015210237114"></p><p>根据从节点的offset与主节点的offset比较 差距就是未同步的数据,只要差距不超过范围(被超了一圈)</p><p>主节点和从节点同步这个缓冲区的数据时 同时移动offset 如果offset一致就完全同步 如果出现了不一致 就要恢复 如果超出范围 说明已经被覆盖了,这时候只能做全量同步</p><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251015211834388.png" alt="image-20251015211834388"></p><p>这个问题没法避免,只能减小概率</p><h3 id="优化主从的数据同步"><a href="#优化主从的数据同步" class="headerlink" title="优化主从的数据同步"></a>优化主从的数据同步</h3><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251015212916833.png" alt="image-20251015212916833"></p><p>(优化全量同步,避免全量同步)</p><p>主节点配置中开启无磁盘复制 减少磁盘io从而减少系统负担 加快全量同步</p><p>减少单节点的内存占用,这样RDB 磁盘IO时候写的少一些(主,从)</p><p>适当提高积压缓冲区的大小,这样就不会太容易超出范围,并且从节点宕机了要即时实现故障恢复,这样避免全量同步</p><p>如果一个master的slave太多,master的压力也很大,可以采用从继续当主节点,实现主-从-从 链式结构</p><h2 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h2><p>如果主也挂了,那写服务就挂了,为了实现无感知(高可用性),要检测节点的健康状态,真的挂了要切换主节点(因为从节点做了数据同步,可以当作主节点),以后以新主节点为主</p><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251015224136448.png" alt="image-20251015224136448"></p><p>哨兵自己也不能挂,所以做集群</p><p>通知redis客户端,告诉他换了主节点</p><h3 id="哨兵监控"><a href="#哨兵监控" class="headerlink" title="哨兵监控"></a>哨兵监控</h3><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251015224527493.png" alt="image-20251015224527493"></p><p>基于心跳机制,给节点发送ping 等待回复pong 如果再规定时间没响应,主观觉得他下线了(主观下线)</p><p>如果超过指定数量的哨兵都觉得他主观下线了,那就公认是下线了(这个指定数量最好是哨兵的一半以上)</p><h3 id="选举新master"><a href="#选举新master" class="headerlink" title="选举新master"></a>选举新master</h3><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251015225523347.png" alt="image-20251015225523347"></p><p>活着并且数据相对最新的 设置优先级 offset看数据到底有多新 都一样的话看runid(节点启动自动生成)从小到大选</p><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251015230439613.png" alt="image-20251015230439613"></p><p>选举完后自己就是主,别人的主就是你,挂掉的主不再是主,而是你的从</p><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251015230606651.png" alt="image-20251015230606651"></p><h3 id="搭建哨兵集群"><a href="#搭建哨兵集群" class="headerlink" title="搭建哨兵集群"></a>搭建哨兵集群</h3><h3 id="redis客户端的哨兵模式"><a href="#redis客户端的哨兵模式" class="headerlink" title="redis客户端的哨兵模式"></a>redis客户端的哨兵模式</h3><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251016102254033.png" alt="image-20251016102254033"></p><p>引入依赖</p><p>配置哨兵地址(由哨兵来服务发现)</p><p>配置读写分离(读取策略)</p><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251016102322561.png" alt="image-20251016102322561"></p><p>剩下的主从切换 由redis客户端自动完成</p><p>单节点内存设置不要太高,避免磁盘io(rdb 全量同步)</p><p>单节点内存上限降低了,但是海量数据要存储?这时候就需要考虑怎么解决这个问题</p><p>而且也要应对 写的高并发</p><h2 id="分片集群"><a href="#分片集群" class="headerlink" title="分片集群"></a>分片集群</h2><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251016110545795.png" alt="image-20251016110545795"></p><p>多个master(都可以写)来分别保存不同数据应对海量数据存储和高并发写</p><p>并且每个主节点可以有多个从节点 这样并发读也可以满足</p><p>master之间相互检测健康状态 ping pong心跳机制</p><p>不在需要sentinel 哨兵来监控 </p><p>可以实现主从切换</p><p>这个redis分片集群的任意节点会有路由机制</p><p>从而通知redis客户端访问正确的节点</p><h3 id="搭建主节点集群"><a href="#搭建主节点集群" class="headerlink" title="搭建主节点集群"></a>搭建主节点集群</h3><h3 id="散列插槽"><a href="#散列插槽" class="headerlink" title="散列插槽"></a>散列插槽</h3><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251016125039574.png" alt="image-20251016125039574"></p><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251016125023121.png" alt="image-20251016125023121"></p><p>存入的数据key和插槽绑定而不是和节点绑定 用CRC16算法得到hash值对16384取余得到index(Slot值)</p><p>数据根据key算出Slot值应该对应在哪个插槽中,找数据就找那一个插槽规管的节点(路由),插槽分配给节点,节点挂了,这个插槽就由另一个节点管</p><p>这样访问任意一个节点访问数据都会重定向到正确的节点去</p><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251016131420180.png" alt="image-20251016131420180"></p><p>如果要将数据保存在同一个 Redis 实例，减少路由和重定向开销，就应该设计 key 的 <code>&#123;&#125;</code> 内部内容（即“哈希标签”）相同。</p><h3 id="集群伸缩"><a href="#集群伸缩" class="headerlink" title="集群伸缩"></a>集群伸缩</h3><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251016133003736.png" alt="image-20251016133003736"></p><p>添加要通知已经存在的</p><p>插槽分配 reshard 将插槽分配给指定节点 然后指定插槽大小 来源 目的地的id</p><h3 id="故障转移-1"><a href="#故障转移-1" class="headerlink" title="故障转移"></a>故障转移</h3><p>自动故障转移</p><p>自动抬升一个它的从节点为主节点</p><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251016141734877.png" alt="image-20251016141734877"></p><p>手动故障转移 (想要更新节点 比如说换一个性能更好的机子 先让这个机子成为它的从节点 )  </p><p>然后手动让这个从节点替换掉原主 成为新主</p><p>​<img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251016142816420.png" alt="image-20251016142816420"></p><p>在这个新的slave上使用cluster failover使主节点宕机,自己成为主节点</p><p>不设置模式时候 首先这个slave告诉要宕机的master ,master的offset</p><p>和从节点的对比 做到数据同步(处理新的请求也要同步过来)</p><p>然后slave把自己变成主,master变成从</p><p>并且通知其他节点</p><p>force就忽略数据一致性</p><ul><li>跳过了“检查数据是否完全同步”的步骤。</li><li>不管主节点有没有新的写操作，直接开始切换。</li></ul><p> takeover暴力夺权</p><p><strong>不通知主节点</strong></p><p><strong>不检查数据一致性</strong></p><p><strong>不等其他节点同意</strong></p><p><strong>直接把自己设为 master</strong></p><p>原主节点如果还活着，会被它当成从节点</p><h3 id="redis客户端使用分片集群"><a href="#redis客户端使用分片集群" class="headerlink" title="redis客户端使用分片集群"></a>redis客户端使用分片集群</h3><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251016151756578.png" alt="image-20251016151756578"></p><h2 id="多级缓存策略"><a href="#多级缓存策略" class="headerlink" title="多级缓存策略"></a>多级缓存策略</h2><p><img src="https://yihgyi.oss-cn-beijing.aliyuncs.com/img/image-20251016154549514.png" alt="image-20251016154549514"></p><p>浏览器缓存静态资源,</p><p>Nginx本地缓存 把之前请求的响应结果（比如页面、接口数据）存在 Nginx 节点的内存里</p><p>Redis分布式缓存</p><p>JVM进程缓存(存到本地的内存中)</p><p>其中nginx访问redis学lua脚本  这么多缓存最终要和数据库保持同步</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java连接数据库</title>
      <link href="/2025/09/07/JDBC/"/>
      <url>/2025/09/07/JDBC/</url>
      
        <content type="html"><![CDATA[<h1 id="JDBC详解"><a href="#JDBC详解" class="headerlink" title="JDBC详解"></a>JDBC详解</h1><p><strong>为了访问不同的数据库提供的一个同一接口</strong></p><p>不同的数据库开发者提供实现了jdbc接口的<strong>驱动程序</strong>就可以通过该驱动程序<strong>访问该数据库</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727221524755.png" alt="image-20250727221524755"></p><h2 id="JDBC使用步骤"><a href="#JDBC使用步骤" class="headerlink" title="JDBC使用步骤"></a>JDBC<strong>使用步骤</strong></h2><ul><li>注册驱动</li><li>得到连接</li></ul><p>底层走的是网络连接 <strong>数据库端口</strong>和访问数据库的<strong>程序的端口</strong>(自动分配&#x2F;指定)</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727222709449.png" alt="image-20250727222709449"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727222418134.png" alt="image-20250727222418134"></p><ul><li>执行sql</li></ul><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727222858531.png" alt="image-20250727222858531"></p><p>真正接收sql和执行返回响应数据的是<code>statement</code></p><ul><li>关闭连接资源</li></ul><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727231417499.png" alt="image-20250727231417499"></p><p>statement资源和连接资源</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727230320803.png" alt="image-20250727230320803"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727230336105.png" alt="image-20250727230336105"></p><h2 id="jdbc连接5种方式"><a href="#jdbc连接5种方式" class="headerlink" title="jdbc连接5种方式"></a>jdbc连接5种方式</h2><h3 id="1-所有东西都是静态写定"><a href="#1-所有东西都是静态写定" class="headerlink" title="1.所有东西都是静态写定"></a>1.所有东西都是静态写定<img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727223223606.png" alt="image-20250727223223606"></h3><h3 id="2-动态加载驱动类"><a href="#2-动态加载驱动类" class="headerlink" title="2.动态加载驱动类"></a>2.动态加载驱动类</h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727223340526.png" alt="image-20250727223340526"></p><h3 id="3-用DriverManager类直接管理驱动类资源"><a href="#3-用DriverManager类直接管理驱动类资源" class="headerlink" title="3.用DriverManager类直接管理驱动类资源"></a>3.用DriverManager类直接管理驱动类资源</h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727223914704.png" alt="image-20250727223914704"></p><h3 id="4-不需要手动注册驱动"><a href="#4-不需要手动注册驱动" class="headerlink" title="4.不需要手动注册驱动"></a>4.不需要手动注册驱动<img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727224158398.png" alt="image-20250727224158398"></h3><p>加载类时候自己static<strong>注册了</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727224326441.png" alt="image-20250727224326441"></p><h3 id="5-不需要手动加载类-jdbc配置文件参数写好了会自动加载类"><a href="#5-不需要手动加载类-jdbc配置文件参数写好了会自动加载类" class="headerlink" title="5.不需要手动加载类(jdbc配置文件参数写好了会自动加载类)"></a>5.不需要手动加载类(jdbc配置文件参数写好了会自动加载类)</h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727224416279.png" alt="image-20250727224416279"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727224433492.png" alt="image-20250727224433492"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727224454602.png" alt="image-20250727224454602"></p><p>建议把静态写定的<strong>url</strong> <strong>user</strong> <strong>pwd</strong> 用配置文件代替</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727224613540.png" alt="image-20250727224613540"></p><p>加载类建议写上</p><h2 id="结果集ResultSet"><a href="#结果集ResultSet" class="headerlink" title="结果集ResultSet"></a>结果集ResultSet</h2><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727224814981.png" alt="image-20250727224814981"></p><p>返回结果 方式调用不方便 复用性不高</p><p>&#x3D;&gt; 数据库返回的表 可以对应创建出一个类(所有属性用包装类)</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727225046379.png" alt="image-20250727225046379"></p><p>返回的结果集数据是一个<strong>对象数组</strong></p><h2 id="Sql注入"><a href="#Sql注入" class="headerlink" title="Sql注入"></a>Sql注入</h2><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727225353068.png" alt="image-20250727225353068"></p><p>因为<strong>Statement</strong>接受的sql语句是字符串 参数和指令靠传统的+来拼接 容易出现拼接结果传给数据库读取错误</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727225544594.png" alt="image-20250727225544594"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727230000686.png" alt="image-20250727230000686"></p><p>改善方法:</p><p><strong>PreparedStatement</strong></p><p>使用?来代替字符串中参数的位置</p><p>再使用 setXXX(序号,xxx)来赋值 然后数据库先识别<strong>指令</strong>部分 再接收<strong>参数数据</strong>部分</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="数据库术语"><a href="#数据库术语" class="headerlink" title="数据库术语"></a>数据库术语</h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727230907814.png" alt="image-20250727230907814"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727231711544.png" alt="image-20250727231711544"></p><p><strong>编译异常转换成运行时异常</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727232053356.png" alt="image-20250727232053356"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727232031495.png" alt="image-20250727232031495"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727233332898.png" alt="image-20250727233332898"></p><h2 id="JDBC-API"><a href="#JDBC-API" class="headerlink" title="JDBC API"></a>JDBC API</h2><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727231056473.png" alt="image-20250727231056473"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727231222489.png" alt="image-20250727231222489"></p><h2 id="jdbc封装成工具类"><a href="#jdbc封装成工具类" class="headerlink" title="jdbc封装成工具类"></a>jdbc封装成工具类</h2><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727231544216.png" alt="image-20250727231544216"></p><h2 id="jdbc事务"><a href="#jdbc事务" class="headerlink" title="jdbc事务"></a>jdbc事务</h2><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727233859101.png" alt="image-20250727233859101"></p><h2 id="批处理查询"><a href="#批处理查询" class="headerlink" title="批处理查询"></a>批处理查询</h2><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727234046277.png" alt="image-20250727234046277"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727234152235.png" alt="image-20250727234152235"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>反射基础</title>
      <link href="/2025/09/07/%E5%8F%8D%E5%B0%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2025/09/07/%E5%8F%8D%E5%B0%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>镜像原理</p><p><img src="C:\Users\yuyiT\AppData\Roaming\Typora\typora-user-images\image-20250727122819383.png" alt="image-20250727122819383"></p><h2 id="引出反射-案例导入"><a href="#引出反射-案例导入" class="headerlink" title="引出反射 (案例导入)"></a>引出反射 (案例导入)</h2><p>**背景:**知道类路径,想快速创建类出来(不通过导入) 并且调用该类的方法</p><p>读取到的类路径是一个字符串,不能通过这个字符串直接new一个对象</p><p>(虽然说如果创建出了对象可以直接通过正向调用方法)</p><p>万物即对象 方法也可以构成对象</p><p><img src="C:\Users\yuyiT\AppData\Roaming\Typora\typora-user-images\image-20250727114813770.png" alt="image-20250727114813770"></p><h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p>通过类加载器ClassLoader 由系统生成(<code>loadClass()</code>) 然后生成Class类的对象 且加载只会有一次</p><p><img src="C:\Users\yuyiT\AppData\Roaming\Typora\typora-user-images\image-20250727120644771.png" alt="image-20250727120644771"></p><h2 id="Java程序三阶段"><a href="#Java程序三阶段" class="headerlink" title="Java程序三阶段"></a>Java程序三阶段</h2><p><img src="C:\Users\yuyiT\AppData\Roaming\Typora\typora-user-images\image-20250727130202605.png" alt="image-20250727130202605"></p><ul><li>代码阶段&#x2F;编译阶段</li></ul><p><strong>java源文件</strong>编译成<strong>字节码文件</strong> (.class)</p><ul><li>类加载阶段</li></ul><p>系统调用类加载器<strong>ClassLoader 的loadClass()<strong>把</strong>字节码文件</strong>的二进制数据加载到方法区(类的信息都在那 <strong>元数据</strong>)</p><p>还会创建出对应的<strong>Class类对象</strong> 里面是完整的<strong>类结构信息</strong> (属性 构造器 方法… 都是对象数组)</p><p><img src="C:\Users\yuyiT\AppData\Roaming\Typora\typora-user-images\image-20250727124701588.png" alt="image-20250727124701588"></p><ul><li>运行阶段(Runtime)</li></ul><p>类加载完通过new来生成对象</p><p>该对象会记得自己对应的<strong>Class类对象</strong></p><h2 id="获得Class类的四个方式"><a href="#获得Class类的四个方式" class="headerlink" title="获得Class类的四个方式"></a>获得Class类的四个方式</h2><p><img src="C:\Users\yuyiT\AppData\Roaming\Typora\typora-user-images\image-20250727123254973.png" alt="image-20250727123254973"></p><p><img src="C:\Users\yuyiT\AppData\Roaming\Typora\typora-user-images\image-20250727123421511.png" alt="image-20250727123421511"></p><p><img src="C:\Users\yuyiT\AppData\Roaming\Typora\typora-user-images\image-20250727123353994.png" alt="image-20250727123353994"></p><p><img src="C:\Users\yuyiT\AppData\Roaming\Typora\typora-user-images\image-20250727123639462.png" alt="image-20250727123639462"></p><p><img src="C:\Users\yuyiT\AppData\Roaming\Typora\typora-user-images\image-20250727123539908.png" alt="image-20250727123539908"></p><p><img src="C:\Users\yuyiT\AppData\Roaming\Typora\typora-user-images\image-20250727123620906.png" alt="image-20250727123620906"></p><p><strong>万物皆对象</strong></p><p><img src="C:\Users\yuyiT\AppData\Roaming\Typora\typora-user-images\image-20250727123702920.png" alt="image-20250727123702920"></p><p><img src="C:\Users\yuyiT\AppData\Roaming\Typora\typora-user-images\image-20250727123728472.png" alt="image-20250727123728472"></p><h2 id="类加载的阶段"><a href="#类加载的阶段" class="headerlink" title="类加载的阶段"></a>类加载的阶段</h2><p><img src="C:\Users\yuyiT\AppData\Roaming\Typora\typora-user-images\image-20250727124241995.png" alt="image-20250727124241995"></p><p>通过反射可以动态加载类</p><p>类加载的时机:</p><ul><li>创建对象 new 静态加载</li><li>子类被加载,父类也会被加载</li><li>调用类的静态成员</li><li><strong>通过反射</strong>动态加载</li></ul><p><strong>加载阶段</strong></p><p><img src="C:\Users\yuyiT\AppData\Roaming\Typora\typora-user-images\image-20250727125042780.png" alt="image-20250727125042780"></p><p><strong>连接阶段</strong></p><ul><li><p><strong>验证</strong></p><p><img src="C:\Users\yuyiT\AppData\Roaming\Typora\typora-user-images\image-20250727125207723.png" alt="image-20250727125207723"></p><p>安全验证</p><p><img src="C:\Users\yuyiT\AppData\Roaming\Typora\typora-user-images\image-20250727125354546.png" alt="image-20250727125354546"></p></li><li><p><strong>准备</strong></p></li></ul><p><img src="C:\Users\yuyiT\AppData\Roaming\Typora\typora-user-images\image-20250727125415036.png" alt="image-20250727125415036"></p><p>默认初始化</p><p><img src="C:\Users\yuyiT\AppData\Roaming\Typora\typora-user-images\image-20250727125459999.png" alt="image-20250727125459999"></p><ul><li><p>解析</p><p><img src="C:\Users\yuyiT\AppData\Roaming\Typora\typora-user-images\image-20250727125533493.png" alt="image-20250727125533493"></p></li></ul><p>相对引用 转换为绝对引用  或者逻辑引用-&gt;物理引用</p><ul><li>初始化</li></ul><p><img src="C:\Users\yuyiT\AppData\Roaming\Typora\typora-user-images\image-20250727125744604.png" alt="image-20250727125744604"></p><p><strong>锁可以保证类只被加载一次</strong> 不会出现同时加载一个类然后出现这个类被加载多次的情况</p><h2 id="通过反射创建对象"><a href="#通过反射创建对象" class="headerlink" title="通过反射创建对象"></a><strong>通过反射创建对象</strong></h2><p>公有无参可以直接用类对象.newInstance() 来创建 其他则需得到构造器 再.newInstance(类对象传参)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Tlias中学到的Spring架构</title>
      <link href="/2025/09/07/Tlias%E4%B8%AD%E5%AD%A6%E5%88%B0%E7%9A%84Spring%E6%9E%B6%E6%9E%84/"/>
      <url>/2025/09/07/Tlias%E4%B8%AD%E5%AD%A6%E5%88%B0%E7%9A%84Spring%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Web中经典三层架构分层解耦spring"><a href="#Web中经典三层架构分层解耦spring" class="headerlink" title="Web中经典三层架构分层解耦spring"></a>Web中经典三层架构分层解耦spring</h1><h2 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h2><p>依据单一职责原则</p><p>把原来的一个程序划分:</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727174231264.png" alt="image-20250727174231264"></p><p>数据访问分为一层</p><ul><li>Dao：数据访问层(Data Access Object)，也称为持久层。负责数据访问操作，包括数据的增、删、改、查。</li></ul><p>中间业务逻辑处理分为一层</p><ul><li>Service：业务逻辑层。处理具体的业务逻辑。</li></ul><p>剩下的一层接收请求,返回响应数据(控制层)</p><ul><li>Controller：控制层。接收前端发送的请求，对请求进行处理，并响应数据</li></ul><p>代码拆分:</p><p>UserDao接口 UserService接口 </p><p>接口式编程</p><h2 id="解耦IOC"><a href="#解耦IOC" class="headerlink" title="解耦IOC"></a>解耦IOC</h2><ul><li><strong>内聚：</strong>软件中各个功能模块内部的功能联系。</li><li><strong>耦合：</strong>衡量软件中各个层&#x2F;模块之间的依赖、关联的程度。</li></ul><p>新流程: 控制层 -&gt;接收响应-&gt;处理业务逻辑-&gt;访问数据</p><p>控制层和业务逻辑层:new xxxService();</p><p>业务逻辑层和数据层 new xxxDao();</p><p>如果有很多个对象就要修改对象的相关代码</p><p>关联程度太大了</p><p>这时候用注解来解耦</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727175352252.png" alt="image-20250727175352252"></p><ul><li><strong>bean对象：</strong>IOC容器中创建、管理的对象，称之为：bean对象。</li></ul><ul><li><strong>控制反转：</strong> Inversion Of Control，简称<strong>IOC</strong>。对象的创建控制权由程序自身转移到外部（容器），这种思想称为控制反转。<ul><li>对象的创建权由程序员主动创建转移到容器(由容器创建、管理对象)。这个容器称为：IOC容器或Spring容器。</li></ul></li></ul><p>把对象放进容器里 这样控制权交给外部容器 而不是写死在程序内部 </p><p>然后再从容器中取出资源</p><ul><li><p><strong>依赖注入：</strong> Dependency Injection，简称<strong>DI</strong>。容器为应用程序提供运行时，所依赖的资源，称之为依赖注入。</p><ul><li>程序运行时需要某个资源，此时容器就为其提供这个资源。</li></ul><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727175820491.png" alt="image-20250727175820491"></p><p>控制层标的是<code>@RestController</code>&#x3D;<code>@Controller</code>+<code>@responseBody</code></p><p>@Controller 里面有@Component</p></li></ul><h2 id="注入DI"><a href="#注入DI" class="headerlink" title="注入DI"></a>注入DI</h2><p><code>AutoWired</code></p><p>1). 属性注入(代码简洁、方便快速开发)</p><p>2). 构造函数注入(依赖度最高 能清晰看到类的依赖 便于管理 规范)</p><p>3). setter注入(类封装性)</p><h2 id="如果容器中相同类型的对象有多个"><a href="#如果容器中相同类型的对象有多个" class="headerlink" title="如果容器中相同类型的对象有多个"></a>如果容器中相同类型的对象有多个</h2><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727180432171.png" alt="image-20250727180432171"></p><p>1.在资源类加上@primary注解</p><p>2.配合@Autowired 加上@Qualifier</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Qualifier(&quot;userServiceImpl&quot;)</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br></pre></td></tr></table></figure><p>3.指定名字(这个是jdk注解类本身提供的)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="meta">@Resource(name = &quot;userServiceImpl&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br></pre></td></tr></table></figure><h2 id="面试题：-Autowird-与-Resource的区别"><a href="#面试题：-Autowird-与-Resource的区别" class="headerlink" title="面试题：@Autowird 与 @Resource的区别"></a>面试题：@Autowird 与 @Resource的区别</h2><ul><li><p>@Autowired 是spring框架提供的注解，而@Resource是JDK提供的注解</p></li><li><p>@Autowired 默认是按照类型注入，而@Resource是按照名称注入</p></li></ul><h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><p><strong>AOP</strong>:面向切面&#x2F;方面编程 Aspect 面向特别方法编程</p><p>底层是动态代理,可以面向方法前后&#x2F;全过程执行一些共同的逻辑</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810114058587.png" alt="image-20250810114058587"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810120243750.png" alt="image-20250810120243750"></p><p>使用</p><ul><li>导入AOP依赖 有spring父级 不用手动确定版本号</li><li>编写AOP切面类 @Component交给IOC容器 @Aspect声明切面类</li></ul><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810122201554.png" alt="image-20250810122201554"></p><p><strong>AOP核心概念:</strong></p><p>AOP 底层通过动态代理（JDK Proxy 或 CGLIB）在运行时生成代理对象，<strong>拦截目标方法的调用</strong>，在方法执行的特定位置（如前置、后置、异常时）插入通知逻辑。</p><ul><li><strong>连接点:</strong> 可以被AOP控制的方法(暗含方法执行时的从相关信息)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810123246988.png" alt="image-20250810123246988"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810122624839.png" alt="image-20250810122624839"></p><ul><li><strong>通知</strong>:共性功能(重复逻辑)</li></ul><ul><li><strong>没有AOP时</strong>：每个会议组织者都要自己喊“大家先打卡！”（重复代码）。</li><li><strong>用AOP后</strong>：行政部<strong>广播通知</strong>（<code>@Before</code>通知）：“凡会议开始，自动触发打卡！”<br>→ 所有会议<strong>“都知道”这个流程</strong>，无需手动处理。</li></ul><hr><p>❓ <strong>那为什么官方不叫“广播”？</strong></p><p>因为AOP的<strong>Advice</strong>更强调<strong>“干预”</strong>而非“告知”：</p><ul><li><strong>“广播”</strong>：像发公告，接不接收随意（事件驱动模式）。</li><li><strong>“通知”</strong>：在AOP中是<strong>强制性的代码插入</strong>（比如必须验权才能调方法）。</li></ul><hr><p>✅ <strong>总结你的神理解</strong></p><ol><li><p><strong>“通知”在AOP中确实是共性代码</strong>（√ 正确）。  </p></li><li><p><strong>“所有方法都知道” ≈ AOP的代理机制</strong>（√ 本质正确）。  </p></li><li><p>唯一的小偏差：  </p><ul><li>你的理解偏向<strong>“静态共享”</strong>（像公共变量）。  </li><li>实际AOP是<strong>动态插入</strong>（运行时修改行为）。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810133036265.png" alt="image-20250810133036265"></p></li></ol><p>但没关系！程序员的世界需要这种<strong>“不严谨但生动”的比喻</strong>来降低理解门槛。下次你完全可以和别人说：<br><strong>“AOP就是把重复代码像广播一样‘通知’所有方法！”</strong> 🎤💻  </p><p><strong>AOP就是为了让一批方法（核心逻辑）无需修改就能自动应用同一套附加逻辑（通知）。</strong><br><strong>→ 和你说的“所有方法都知道要执行通知”完全</strong></p><ul><li><p><strong>切入点:</strong> 真正控制的方法 <strong>从这些方法下手，插入新逻辑</strong><br><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810133359155.png" alt="image-20250810133359155"></p></li><li><p>**切面: ** <strong>通知与切入点的联系</strong></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810133940264.png" alt="image-20250810133940264"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810134025539.png" alt="image-20250810134025539"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810134014332.png" alt="image-20250810134014332"></p><p> <strong>为什么叫“切面”？</strong></p><ul><li><strong>“切”</strong> &#x3D; 横向选中一批方法（通过切入点）。</li><li><strong>“面”</strong> &#x3D; 这些方法 + 通知逻辑的<strong>组合关系</strong>。</li><li><strong>合起来</strong>：<strong>“通过规则把代码和增强逻辑绑定的方案”</strong>。</li></ul><ol><li><strong>切面 &#x3D; 切入点 + 通知的封装</strong>（就像一份“增强说明书”）。</li><li><strong>它不主动生效</strong>，而是由AOP框架在运行时<strong>动态应用</strong>到匹配的方法上。</li><li><strong>最终效果</strong>：所有符合切入点的方法，调用时自动执行通知逻辑。</li></ol><p>下次可以简单说：<br><strong>“切面就是告诉AOP：哪些方法（切入点）要自动加什么功能（通知）！”</strong> 🎯</p><p>​</p><p><strong>目标对象:</strong> 通知所应用的对象</p><p>通知类型:</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810135753369.png" alt="image-20250810135753369"></p><p>@Pointcut注解 抽取公共切入点表达式</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810135852854.png" alt="image-20250810135852854"></p><p>对于返回值问题:</p><ol><li><p><strong>动态代理的本质</strong>：  </p><ul><li>所有方法调用（包括<code>void</code>方法）<strong>底层都必须返回一个值</strong>（<code>void</code>方法实际返回<code>null</code>）。  </li><li><strong>代理对象</strong>（比如Spring AOP生成的代理）<strong>必须处理这个返回值</strong>，否则JVM会报错。</li></ul></li><li><p><strong>Spring的“偷懒”设计</strong>：  </p><ul><li>对于<code>@Before</code>、<code>@After</code>等通知，Spring说：<strong>“你只管写你的逻辑（<code>void</code>），返回值的麻烦事我来帮你搞定！”</strong>  <ul><li>比如你写<code>@Before</code>，Spring会在代理中自动调用你的代码，然后<strong>替你返回正确的值</strong>（原方法的返回值或<code>null</code>）。</li></ul></li></ul></li><li><p><strong><code>@Around</code>的特殊性</strong>：  </p><ul><li><code>@Around</code>是<strong>全能管家</strong>，Spring说：<strong>“你要自己控制一切（包括返回值），我不帮你兜底！”</strong>  <ul><li>你必须手动调用<code>proceed()</code>（相当于执行原方法），并<strong>自己返回一个值</strong>（哪怕是<code>null</code>）。  </li><li>因为<code>@Around</code>可以<strong>修改返回值</strong>（比如把<code>null</code>改成<code>&quot;成功&quot;</code>），所以Spring无法自动处理。</li></ul></li></ul></li></ol><hr><p><strong>类比：餐厅点餐</strong></p><ul><li><p><strong>普通通知（<code>@Before</code>&#x2F;<code>@After</code>）</strong>：  </p><ul><li>像服务员，只负责记录订单或清理桌子（不需要决定最终上什么菜）。  </li><li><strong>厨房（Spring）</strong>会自动把菜端给顾客（处理返回值）。</li></ul></li><li><p>**<code>@Around</code>**：  </p><ul><li>像厨师长，<strong>亲自做菜</strong>（调用<code>proceed()</code>），还能<strong>改菜谱</strong>（替换返回值）。  </li><li>必须自己把菜端出去（<code>return result</code>），不能甩锅给服务员！</li></ul></li></ul><hr><p><strong>代码对比</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通通知：Spring自动处理返回值</span></span><br><span class="line"><span class="meta">@Before(&quot;execution(* orderFood(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;服务员：记录订单&quot;</span>); <span class="comment">// 不需要返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @Around：必须自己处理返回值</span></span><br><span class="line"><span class="meta">@Around(&quot;execution(* orderFood(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">aroundOrder</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;厨师长：开始做菜&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> pjp.proceed(); <span class="comment">// 做菜（可能返回null或实际值）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;加辣的&quot;</span> + result; <span class="comment">// 必须自己返回！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>最终结论</strong></p><ul><li><strong>动态代理</strong>：强制所有方法返回<code>Object</code>（<code>void</code>返回<code>null</code>）。  </li><li><strong>Spring</strong>：  <ul><li>对普通通知（<code>@Before</code>等）<strong>隐藏返回值细节</strong>（让你写<code>void</code>）。  </li><li>对<code>@Around</code><strong>要求显式返回</strong>（因为你要完全控制流程）。</li></ul></li></ul><p><strong>简单说</strong>：<code>@Around</code>是老板，其他通知是员工，Spring是行政助理——老板得亲力亲为，员工可以偷懒！ 😄</p><p>通知执行的顺序:</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810151910593.png" alt="image-20250810151910593"></p><p>1</p><p>2</p><p>3</p><p>3</p><p>2</p><p>1</p><p><strong>切入点表达式:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810152050203.png" alt="image-20250810152050203"></p><p>可以加上|| &amp;&amp; ! 在复杂情况的时候</p><p>此外 还可以用注解来定位切入点</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810152441097.png" alt="image-20250810152441097"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810152503537.png" alt="image-20250810152503537"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810152520025.png" alt="image-20250810152520025"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810152532559.png" alt="image-20250810152532559"></p><p><strong>连接点</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810152557324.png" alt="image-20250810152557324"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810152925689.png" alt="image-20250810152925689"></p><h2 id="Bean对象"><a href="#Bean对象" class="headerlink" title="Bean对象"></a>Bean对象</h2><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810215634507.png" alt="image-20250810215634507"></p><ul><li>如果不声明Bean的名字,那么默认就是类名(首字母小写)</li></ul><p>默认Bean是单例的 <code>singleton</code></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810215010644.png" alt="image-20250810215010644"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810214903034.png" alt="image-20250810214903034"></p><p>这个IOC容器可以通过<code>getBean(Bean名字字符串)</code>得到Bean对象 但是不知道Bean具体的类型 所以统一用Object</p><p>**项目启动时这个默认单例的Bean就创建了 **然后放入IOC容器中</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810215157019.png" alt="image-20250810215157019"></p><p>@Lazy 懒汉式  – 在Bean类加上这个注解延迟初始化,在第一次使用这个Bean对象的时候才会创建</p><p>非单例&#x2F;多例 </p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810215556417.png" alt="image-20250810215556417"></p><p>加上这个注解 默认是单例<code>@Scope(&quot;singeton&quot;)</code> 加不加都是单例</p><p>单例减少资源成本 (创建对象 数据库连接池 线程池)</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810220126991.png" alt="image-20250810220126991"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810220503073.png" alt="image-20250810220503073"></p><h2 id="Bean面试题"><a href="#Bean面试题" class="headerlink" title="Bean面试题:"></a>Bean面试题:</h2><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810220751154.png" alt="image-20250810220751154"></p><h2 id="第三方Bean"><a href="#第三方Bean" class="headerlink" title="第三方Bean"></a>第三方Bean</h2><p>我们项目开发当中，还有一种情况就是这个类它不是我们自己编写的，而是我们引入的第三方依赖当中提供的，那么此时我们是无法使用 <code>@Component</code> 及其衍生注解来声明bean的，此时就需要使用**<code>@Bean</code>**注解来声明bean 了。</p><p>若要管理的第三方 bean 对象，建议对这些bean进行集中分类配置，可以通过 <code>@Configuration</code> 注解声明一个配置类。<strong>【推荐】</strong></p><p>启动类添加的<code>@SpringBootApplication</code>里面也有一个<code>@Configuration</code>注解</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250811145846354.png" alt="image-20250811145846354"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250811145909408.png" alt="image-20250811145909408"></p><p>所以启动类也是配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.utils.AliyunOSSOperator;</span><br><span class="line"><span class="keyword">import</span> com.itheima.utils.AliyunOSSProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span><span class="comment">//加上这个注解就会加载这个配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OSSConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AliyunOSSOperator <span class="title function_">aliyunOSSOperator</span><span class="params">(<span class="meta">@Autowired</span> (这个注解是自动有的 这里显示写出来提示 标识自动装配 第三方bean需要依赖其他bean对象 这个bean对象需要已经加入IOC容器里)</span>AliyunOSSProperties ossProperties) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AliyunOSSOperator</span>(ossProperties);</span><br><span class="line">    &#125;<span class="comment">//在这里可以将AliyunOSSoperator对象注入到IOC容器中 名字是方法名aliyunOSSOperator</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果第三方bean需要依赖其他bean对象，直接在bean定义方法中设置形参即可，容器会根据类型自动装配。</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810231013302.png" alt="image-20250810231013302"></p><h2 id="springboot中的起步依赖"><a href="#springboot中的起步依赖" class="headerlink" title="springboot中的起步依赖"></a>springboot中的起步依赖</h2><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810231458839.png" alt="image-20250810231458839"></p><p>加入stater依赖就可以自动配置很多依赖 其实就是依靠<strong>依赖传递</strong></p><p>原始的spring框架直接开发</p><ol><li>在pom.xml中依赖配置比较繁琐，在项目开发时，需要自己去找到对应的依赖，还需要找到依赖它所配套的依赖以及对应版本，否则就会出现版本冲突问题。</li><li>在使用Spring框架进行项目开发时，需要在Spring的配置文件中做大量的配置，这就造成Spring框架入门难度较大，学习成本较高。</li></ol><h2 id="springboot就是简化spring框架的配置"><a href="#springboot就是简化spring框架的配置" class="headerlink" title="springboot就是简化spring框架的配置"></a>springboot就是简化spring框架的配置</h2><ul><li>起步依赖<ul><li>比如：springboot-starter-web，这是web开发的起步依赖，在web开发的起步依赖当中，就集成了web开发中常见的依赖：json、web、webmvc、tomcat等。我们只需要引入这一个起步依赖，其他的依赖都会自动的通过Maven的<strong>依赖传递</strong>进来。</li></ul></li><li>自动配置</li></ul><p>表现在: spring容器启动后,一些配置类和bean对象就会自动存入到IOC容器中,不需要我们手动去声明@Bean</p><p>1.添加<code>Gson</code>依赖(spring起步依赖中传递已经引入了<code>Gson</code>的依赖)</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250811143821527.png" alt="image-20250811143821527"></p><p>然后直接导包 并且从IOC容器注入(自动装配到IOC容器了) 这个Bean</p><h2 id="springboot自动配置"><a href="#springboot自动配置" class="headerlink" title="springboot自动配置"></a>springboot自动配置</h2><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250811161510203.png" alt="image-20250811161510203"></p><p>自动配置可能的实现方案:</p><h3 id="1-引入第三方的包-第三方包用-Component声明Bean类"><a href="#1-引入第三方的包-第三方包用-Component声明Bean类" class="headerlink" title="1.引入第三方的包 第三方包用@Component声明Bean类"></a>1.引入第三方的包 第三方包用@Component声明Bean类</h3><p>但是这个Bean没有被扫描到</p><p>在引导类(启动类中)</p><p><code>@SpringBootApplication</code>注解</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250811144819695.png" alt="image-20250811144819695"></p><p>组件扫描的范围是启动类所在包和子包</p><p>所以是扫描不到第三方的</p><p>如果要扫描需要显示添加扫描注解</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250811144949383.png" alt="image-20250811144949383"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250811145031704.png" alt="image-20250811145031704"></p><h3 id="2-Improt导入"><a href="#2-Improt导入" class="headerlink" title="2.@Improt导入"></a>2.<code>@Improt</code>导入</h3><p>   A.导入普通类</p><p>   B.导入配置类 @Configuration声明配置类</p><p>   C.导入<code>ImportSelector</code>接口的实现类</p><p>配置类</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250811145555104.png" alt="image-20250811145555104"></p><p>​</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250811152408744.png" alt="image-20250811152408744"></p><p>第三种</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250811152859168.png" alt="image-20250811152859168"></p><p>实现这个接口 然后方法要实现 返回类型是<code>String[]</code></p><p>里面就是写的要加入的普通类或配置类 bean</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250811153107506.png" alt="image-20250811153107506"></p><p>但是这样的话果基于以上方式完成自动配置，当要引入一个第三方依赖时，还要知道第三方依赖中有哪些配置类和哪些Bean对象</p><p>不用使用第三方依赖的开发者配,让提供第三方依赖的开发者来配</p><p>比较常见的方案就是第三方依赖给我们提供一个注解，这个注解一般都以@EnableXxxx开头的注解，注解中封装的就是@Import注解</p><ul><li>第三方依赖中提供的注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Import(MyImportSelector.class)</span><span class="comment">//指定要导入哪些bean对象或配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableHeaderConfig &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在使用时只需在启动类上加上@EnableXxxxx注解即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableHeaderConfig</span>  <span class="comment">//使用第三方依赖提供的Enable开头的注解</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootWebConfig2Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringbootWebConfig2Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自动配置源码执行流程:</p><p>​<img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250811153519006.png" alt="image-20250811153519006"></p><h3 id="在-EnableAutoConfiguration中"><a href="#在-EnableAutoConfiguration中" class="headerlink" title="在@EnableAutoConfiguration中"></a><strong>在<code>@EnableAutoConfiguration</code>中</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250811153653138.png" alt="image-20250811153653138"></p><p>用到了@Import 的第三种方式</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250811153829127.png" alt="image-20250811153829127"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250811154628379.png" alt="image-20250811154628379"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250811155127248.png" alt="image-20250811155127248"></p><ol><li><strong><code>AutoConfigurationImportSelector</code></strong><ul><li>是 Spring Boot 自动配置的关键类，实现了 <code>DeferredImportSelector</code>，负责在 Spring 容器启动时<strong>延迟加载</strong>自动配置类。</li><li>通过 <code>getCandidateConfigurations()</code> 方法获取候选的自动配置类列表。</li></ul></li><li><strong><code>ImportCandidates.load()</code></strong><ul><li>从类路径下的 <code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code> 文件中读取配置类名。</li><li>文件格式：每行一个自动配置类的全限定名（如 <code>org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration</code>）。</li></ul></li><li><strong>断言 <code>Assert.notEmpty()</code></strong><ul><li>如果文件不存在或内容为空，抛出异常，提示用户检查是否正确地包含了自动配置的声明文件。</li></ul></li></ol><hr><p>我们直接在测试类当中注入了一个叫<code>gson</code>的bean对象，进行JSON格式转换。虽然我们没有配置bean对象，但是我们是可以直接注入使用的。原因就是因为在自动配置类当中做了自动配置</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250811155933486.png" alt="image-20250811155933486"></p><p>打开自动配置类</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250811155947820.png" alt="image-20250811155947820"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250811160014208.png" alt="image-20250811160014208"></p><p><code>就是用的@Import配置类那一套,springboot用@Enablexxx封装了 来读取Meta/INF下面的imports文件里的所有配置类</code></p><p>当SpringBoot程序启动时，就会加载配置文件当中所定义的配置类，并将这些配置类信息(类的全限定名)封装到String类型的数组中，最终通过@Import注解将这些配置类全部加载到Spring的IOC容器中，交给IOC容器管理。</p><h2 id="所有写在文件中的配置类都会被注册到ioc容器中吗"><a href="#所有写在文件中的配置类都会被注册到ioc容器中吗" class="headerlink" title="所有写在文件中的配置类都会被注册到ioc容器中吗?"></a>所有写在文件中的配置类都会被注册到ioc容器中吗?</h2><p>在 <code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code> 文件中定义的配置类非常多，而且每个配置类中又可以定义很多的bean，那这些bean都会注册到Spring的IOC容器中吗？</p><p>并不是。 在声明bean对象时，上面有加一个以 <code>@Conditional</code> 开头的注解，这种注解的作用就是按照条件进行装配，只有满足条件之后，才会将bean注册到Spring的IOC容器中</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250811160816725.png" alt="image-20250811160816725"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250811160946855.png" alt="image-20250811160946855"></p><p>这样就是真正用到的才会加入到IOC容器中</p><h2 id="自定义一个自动配置类-做一个starter"><a href="#自定义一个自动配置类-做一个starter" class="headerlink" title="自定义一个自动配置类 (做一个starter )"></a>自定义一个自动配置类 (做一个starter )</h2><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250811161651544.png" alt="image-20250811161651544"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250811163538633.png" alt="image-20250811163538633"></p><p>官方是springboot写在前面 自定义的话自己的名字写在前面</p><p>starter依赖中主要是对依赖进行管理 所以主要是pom.XML文件 </p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250811164805116.png" alt="image-20250811164805116"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250811171028833.png" alt="image-20250811171028833"></p><h2 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h2><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812122845778.png" alt="image-20250812122845778"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端三剑客</title>
      <link href="/2025/09/07/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2%E5%9F%BA%E7%A1%80/"/>
      <url>/2025/09/07/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%89%91%E5%AE%A2%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="前端三剑客"><a href="#前端三剑客" class="headerlink" title="前端三剑客"></a>前端三剑客</h1><h2 id="网页基础"><a href="#网页基础" class="headerlink" title="网页基础"></a>网页基础</h2><p>网页由哪些部分组成 ?</p><ul><li>文字、图片、音频、视频、超链接、表格等等。</li></ul><p>**我们看到的网页就是前端代码**</p><ul><li>通过<strong>浏览器</strong>转化（解析和渲染）成用户看到的网页</li><li><strong>浏览器</strong>中对代码进行解析和渲染的部分，称为 <strong>浏览器内核</strong></li></ul><p>内核不同导致解析差异,所以指定web标准</p><h2 id="web标准"><a href="#web标准" class="headerlink" title="web标准"></a>web标准</h2><p>W3C(万维网联盟)</p><p>标准:</p><ul><li><p>HTML(网页结构:页面元素和内容)</p></li><li><p>CSS(网页表现:页面外观位置等样式,颜色大小)</p></li><li><p>JavaScript(网页行为:交互效果)</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812124225814.png" alt="image-20250812124225814"></p><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>超文本<code>HypeText</code>:超越了文本的限制，比普通文本更强大。除了文字信息，还可以定义图片、音频、视频等内容。</p><p>标记<code>Mark</code>:由标签 “&lt;标签名&gt;” 构成的语言</p><ul><li>HTML标签都是预定义好的 。例如：使用 <code>&lt;h1&gt;</code> 标签展示标题，使用<code>&lt;a&gt;</code>展示超链接，使用<code>&lt;img&gt;</code>展示图片，<code>&lt;video&gt;</code>展示视频。</li></ul><p>语言<code>Language</code></p><ul><li>HTML代码直接在浏览器中运行，HTML标签由浏览器解析 。</li><li><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812124500911.png" alt="image-20250812124500911"></li></ul><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="margin外边距"><a href="#margin外边距" class="headerlink" title="margin外边距"></a><code>margin</code>外边距</h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812131407744.png" alt="image-20250812131407744"></p><table><thead><tr><th>名称</th><th>语法描述</th><th>示例</th></tr></thead><tbody><tr><td>行内样式</td><td>在标签内使用style属性，属性值是css属性键值对。</td><td><code>&lt;h1 style=&quot;xxx:xxx;&quot;&gt;中国新闻网&lt;/h1&gt;</code></td></tr><tr><td>内部样式</td><td>定义<code>&lt;style&gt;</code>标签，在标签内部定义css样式。</td><td><code>&lt;style&gt; h1 &#123;...&#125; &lt;/style&gt;</code></td></tr><tr><td>外部样式</td><td>定义<code>&lt;link&gt;</code>标签，通过href属性引入外部css文件</td><td><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;css/news.css&quot;&gt;</code></td></tr></tbody></table><table><thead><tr><th>表示方式</th><th>属性值</th><th>说明</th><th>取值</th></tr></thead><tbody><tr><td>关键字</td><td>颜色英文单词</td><td>red、green、blue</td><td>red、green、blue…</td></tr><tr><td>rgb表示法</td><td>rgb(r, g, b)</td><td>红绿蓝三原色，每项取值范围：0-255</td><td>rgb(0,0,0)、rgb(255,255,255)、rgb(255,0,0)</td></tr><tr><td>rgba表示法</td><td>rgba(r, g, b, a)</td><td>红绿蓝三原色，a表示透明度，取值：0-1</td><td>rgb(0,0,0,0.3)、rgb(255,255,255,0.5)</td></tr><tr><td>十六进制表示法</td><td>#rrggbb</td><td>#开头，将数字转换成十六进制表示</td><td>#000000、#ff0000、#cccccc，简写：#000、#ccc</td></tr></tbody></table><table><thead><tr><th>选择器</th><th>写法</th><th align="center">示例</th><th>示例说明</th></tr></thead><tbody><tr><td>元素选择器</td><td><code>元素名称 &#123;...&#125;</code></td><td align="center"><code>h1 &#123;...&#125;</code></td><td>选择页面上所有的<code>&lt;h1&gt;</code>标签</td></tr><tr><td>类选择器</td><td><code>.class属性值 &#123;...&#125;</code></td><td align="center"><code>.cls &#123;...&#125;</code></td><td>选择页面上所有class属性为cls的标签</td></tr><tr><td>id选择器</td><td><code>#id属性值 &#123;...&#125;</code></td><td align="center"><code>#hid &#123;...&#125;</code></td><td>选择页面上id属性为hid的标签</td></tr><tr><td>分组选择器</td><td>选择器1,选择器2{…}</td><td align="center"><code>h1,h2 &#123;...&#125;</code></td><td>选择页面上所有的<code>&lt;h1&gt;</code>和<code>&lt;h2&gt;</code>标签</td></tr><tr><td>属性选择器</td><td>元素名称[属性] {…}</td><td align="center"><code>input[type] &#123;...&#125;</code></td><td>选择页面上有type属性的<code>&lt;input&gt;</code>标签</td></tr><tr><td>元素名称[属性名&#x3D;”值”] {…}</td><td><code>input[type=&quot;text&quot;] &#123;...&#125;</code></td><td align="center">选择页面上type属性为text的<code>&lt;input&gt;</code>标签</td><td></td></tr><tr><td>后代选择器</td><td>元素1元素2{…}</td><td align="center"><code>form input &#123;...&#125;</code></td><td>选择<code>&lt;form&gt;</code>标签内的所有<code>&lt;input&gt;</code>标签</td></tr></tbody></table><ul><li><strong>CSS:</strong> Cascading Style Sheet，层叠样式表，用于控制页面的样式（表现）。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812124515263.png" alt="image-20250812124515263"></p><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型:"></a>盒子模型:</h3><ul><li>盒子：页面中所有的元素（标签），都可以看做是一个 盒子，由盒子将页面中的元素包含在一个矩形区域内，通过盒子的视角更方便的进行页面布局。</li><li>盒子模型组成：内容区域（content）、内边距区域（padding）、边框区域（border）、外边距区域（margin）。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812131531652.png" alt="image-20250812131531652"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812131544238.png" alt="image-20250812131544238"></p><p>盒子的大小，其实就包括三个部分： border、padding、content，而margin外边距是不包括在盒子之内的。</p><h2 id="flex弹性布局"><a href="#flex弹性布局" class="headerlink" title="flex弹性布局"></a>flex弹性布局</h2><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812132812609.png" alt="image-20250812132812609"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">display</span>: flex;      <span class="comment">/* justify-content: space-between; */</span> <span class="comment">/* 先两边贴边，再平分剩余空间 */</span>     </span><br><span class="line">                    <span class="comment">/* justify-content: flex-start;*/</span> <span class="comment">/* 从头开始排列  */</span>      </span><br><span class="line">                    <span class="comment">/* justify-content: flex-end; */</span> <span class="comment">/* 从尾开始排列 */</span>     </span><br><span class="line">                    <span class="comment">/* justify-content: center; */</span> <span class="comment">/* 居中排列 */</span>      </span><br><span class="line">                    <span class="comment">/* justify-content: space-around; */</span> <span class="comment">/* 两边留白，中间平分，平分剩余空间 */</span>      </span><br><span class="line"><span class="attribute">flex-direction</span>: row;      </span><br><span class="line"><span class="attribute">justify-content</span>: space-between;      </span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#aeea6a</span>;     </span><br><span class="line"><span class="attribute">width</span>: <span class="number">400px</span>;      </span><br><span class="line"><span class="attribute">height</span>: <span class="number">300px</span>;    </span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>说明</th><th>取值</th><th>含义</th></tr></thead><tbody><tr><td>display</td><td>模式</td><td>flex</td><td>使用flex布局</td></tr><tr><td>flex-direction</td><td>设置主轴</td><td>row</td><td>主轴方向为x轴，水平向右。（默认）</td></tr><tr><td></td><td></td><td>column</td><td>主轴方向为y轴，垂直向下。</td></tr><tr><td>justify-content</td><td>子元素在主轴上的对齐方式</td><td>flex-start</td><td>从头开始排列</td></tr><tr><td></td><td></td><td>flex-end</td><td>从尾部开始排列</td></tr><tr><td></td><td></td><td>center</td><td>在主轴居中对齐</td></tr><tr><td></td><td></td><td>space-around</td><td>平分剩余空间</td></tr><tr><td></td><td></td><td>space-between</td><td>先两边贴边，再平分剩余空间</td></tr></tbody></table><h2 id="html结构"><a href="#html结构" class="headerlink" title="html结构"></a>html结构</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">title</span>&gt;</span>HTML 快速入门<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">                </span><br><span class="line">     <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;head&gt;</code> : 定义网页的头部，用来存放给浏览器看的信息，如：CSS样式、网页的标题。 </li><li><code>&lt;body&gt;</code> : 定义网页的主体部分，存放给用户看的信息，也是网页的主体内容，如：文字、图片、视频、音频、表格等。</li></ul><p>特点:</p><ul><li>不区分大小写</li><li>属性值可以用单引号,双引号</li></ul><p><strong>浏览器中渲染的时候，是从上往下逐行解析展示的</strong></p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.table</span> &#123;</span><br><span class="line">   <span class="attribute">min-width</span>: <span class="number">100%</span>; </span><br><span class="line">   <span class="attribute">border-collapse</span>: collapse;</span><br><span class="line">   <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置表格单元格边框 */</span></span><br><span class="line"><span class="selector-class">.table</span> <span class="selector-tag">td</span>, <span class="selector-class">.table</span> <span class="selector-tag">th</span> &#123; </span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ddd</span>; </span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">8px</span>; </span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.avatar</span> &#123; </span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>; </span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>; </span><br><span class="line">  <span class="attribute">object-fit</span>: cover; </span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table>  <caption>表格标题</caption>  <thead>    <tr>      <th>表头1</th>      <th>表头2</th>    </tr>  </thead>  <tbody>    <tr>      <td>数据1</td>      <td>数据2</td>    </tr>    <tr>      <td>数据3</td>      <td>数据4</td>    </tr>  </tbody>  <tfoot>    <tr>      <td>页脚1</td>      <td>页脚2</td>    </tr>  </tfoot></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">caption</span>&gt;</span>表格标题<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>表头1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>表头2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>数据1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>数据2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>数据3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>数据4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tfoot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>页脚1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>页脚2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tfoot</span>&gt;</span>   可以省略这个</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">--------------------------------------------------------------------------------------------------</span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span>&gt;</span> - 定义表格容器</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">caption</span>&gt;</span> - 表格标题（可选）</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span> - 表头区域（可选）</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span> - 表格主体（必须）</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">tfoot</span>&gt;</span> - 表脚区域（可选）</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> - 表格行（table row）</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span> - 表头单元格（table header）</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span> - 标准单元格（table data）</span><br></pre></td></tr></table></figure><h2 id="常见标签"><a href="#常见标签" class="headerlink" title="常见标签:"></a>常见标签:</h2><h3 id="lt-h-gt-标题-lt-h-gt"><a href="#lt-h-gt-标题-lt-h-gt" class="headerlink" title="&lt;h&gt;标题&lt;/h&gt;"></a><code>&lt;h&gt;标题&lt;/h&gt;</code></h3><p>h1为一级标题，字体也是最大的 ； h6为六级标题，字体是最小的。</p><p><strong>注意：</strong>HTML标签是预定义好的，不能随意定义，也就以为着，标题标签就只有这六个，没有 <code>&lt;h7&gt;</code></p><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><p><code>&lt;!-- 定义一个超链接, 链接地址：https://news.cctv.com/, 链接内容：央视网 --&gt; </code></p><p><code> &lt;a href=&quot;https://news.cctv.com/&quot; target=&quot;_blank&quot;&gt;央视网&lt;/a&gt;  2024年05月15日 20:07</code></p><p>target这里属性**_blank**是新建页面打开链接</p><p> <strong>设置超链接取消下划线效果</strong><code>css</code></p><p>  <code>  a &#123;      text-decoration: none;    &#125;</code>  </p><p><strong>_self</strong>是在本页面打开</p><h3 id="lt-span-gt-lt-span-gt"><a href="#lt-span-gt-lt-span-gt" class="headerlink" title="&lt;span&gt;&lt;/span&gt;"></a><code>&lt;span&gt;&lt;/span&gt;</code></h3><p> span一行会显示多个，用来组合行内元素，默认宽度为内容撑开的宽度。不可以设置宽高（width、height）</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812132158505.png" alt="image-20250812132158505"></p><h3 id="lt-div-gt-lt-div-gt"><a href="#lt-div-gt-lt-div-gt" class="headerlink" title="&lt;div&gt;&lt;/div&gt;"></a><code>&lt;div&gt;&lt;/div&gt;</code></h3><p> div会独占一行，默认宽度为父元素 body 的宽度。可以设置宽高（width、height）</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812132144811.png" alt="image-20250812132144811"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812132351287.png" alt="image-20250812132351287"></p><h3 id="lt-br-gt-换行"><a href="#lt-br-gt-换行" class="headerlink" title="&lt;br&gt;换行"></a><code>&lt;br&gt;</code>换行</h3><h3 id="lt-p-gt-段落-lt-p-gt"><a href="#lt-p-gt-段落-lt-p-gt" class="headerlink" title="&lt;p&gt;段落&lt;/p&gt;"></a><code>&lt;p&gt;段落&lt;/p&gt;</code></h3><p>   &#x2F;* 设置段落首行缩进 <em>&#x2F;    p {      text-indent: 2em; &#x2F;</em> 首行缩进2em <em>&#x2F;      line-height: 2; &#x2F;</em> 行高2倍 *&#x2F;    }</p><table><thead><tr><th>标签</th><th>作用</th><th>属性&#x2F;说明</th></tr></thead><tbody><tr><td><code>&lt;video&gt;</code></td><td>视频标签</td><td>src：指定视频的url（绝对路径&#x2F;相对路径）</td></tr><tr><td>controls：是否显示播放控件</td><td></td><td></td></tr><tr><td>width：宽度（像素&#x2F;相对于父元素百分比）；备注: 一般width 和 height 我们只会指定一个，另外一个会自动的等比例缩放。</td><td></td><td></td></tr><tr><td>height：高度（像素&#x2F;相对于父元素百分比）；备注: 一般width 和 height 我们只会指定一个，另外一个会自动的等比例缩放。</td><td></td><td></td></tr><tr><td><code>&lt;img&gt;</code></td><td>图片标签</td><td>src, width，height</td></tr><tr><td><code>&lt;p&gt;</code></td><td>段落标签</td><td></td></tr><tr><td><code>&lt;br&gt;</code></td><td>换行标签</td><td></td></tr><tr><td><code>&lt;b&gt; / &lt;strong&gt;</code></td><td>加粗</td><td><code>&lt;strong&gt; </code>具有强调语义</td></tr><tr><td><code>&lt;u&gt; / &lt;ins&gt;</code></td><td>下划线</td><td><code>&lt;ins&gt; </code>具有强调语义</td></tr><tr><td><code>&lt;i&gt; / &lt;em&gt;</code></td><td>倾斜</td><td><code>&lt;em&gt; </code>具有强调语义</td></tr><tr><td><code>&lt;s&gt; / &lt;del&gt;</code></td><td>删除线</td><td><code>&lt;del&gt; </code>具有强调语义</td></tr></tbody></table><table><thead><tr><th>字符实体</th><th>属性&#x2F;说明</th></tr></thead><tbody><tr><td><code>&amp;nbsp;</code></td><td>空格</td></tr><tr><td><code>&amp;lt;</code></td><td>&lt;</td></tr><tr><td><code>&amp;gt;</code></td><td>&gt;</td></tr></tbody></table><p>在HTML页面中，我们在代码中录入空格、&lt;、&gt; 这些符号的时候，是没有对应的效果的，因为浏览器并不能准确的识别，此时，我们就需要通过字符实体来表示空格，&lt;, &gt; 。</p><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812133035873.png" alt="image-20250812133035873"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812133110199.png" alt="image-20250812133110199"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812133129914.png" alt="image-20250812133129914"></p><table><thead><tr><th>type取值</th><th>描述</th></tr></thead><tbody><tr><td>text</td><td>默认值，定义单行的输入字段</td></tr><tr><td>password</td><td>定义密码字段</td></tr><tr><td>radio</td><td>定义单选按钮</td></tr><tr><td>checkbox</td><td>定义复选框</td></tr><tr><td>file</td><td>定义文件上传按钮</td></tr><tr><td>date&#x2F;time&#x2F;datetime-local</td><td>定义日期&#x2F;时间&#x2F;日期时间</td></tr><tr><td>number</td><td>定义数字输入框</td></tr><tr><td>email</td><td>定义邮件输入框</td></tr><tr><td>hidden</td><td>定义隐藏域</td></tr><tr><td>submit &#x2F; reset &#x2F; button</td><td>定义提交按钮 &#x2F; 重置按钮 &#x2F; 可点击按钮</td></tr></tbody></table><ul><li><p><code>&lt;select&gt;</code>: 定义下拉列表, <code>&lt;option&gt;</code> 定义列表项</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812133248119.png" alt="image-20250812133248119"></p></li><li><p><code>&lt;textarea&gt;</code>: 文本域</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812133414027.png" alt="image-20250812133414027"></p><p>而对于<code>&lt;input type=&quot;hidden&quot;&gt;</code>，是一个隐藏域，在表单中并不会显示出来，但是在提交表单的时候，是会提交到服务端的。</p><p>表单中的所有表单项，要想能够正常的采集数据，在提交的时候能提交到服务端，表单项必须指定name属性。 否则，无法提交该表单项。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h2><p>在引入图片、视频、音频、css等内容时，我们需要指定文件的路径，而在前端开发中，路径的书写形式分为两类：</p><ul><li><h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径:"></a>绝对路径:</h3><p>绝对磁盘路径: <code>&lt;img src=&quot;C:\Users\Administrator\Desktop\HTML\img\logo.png&quot;&gt;</code></p><p>绝对网络路径: <code>&lt;img src=&quot;https://i2.sinaimg.cn/dy/deco/2012/0613/yocc20120613img01/news_logo.png&quot;&gt;</code></p></li><li><h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径:"></a>相对路径:</h3></li></ul><p>​        .&#x2F; : 当前目录 , .&#x2F; 可以省略的</p><p>​        ..&#x2F;: 上一级目录</p><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812142045304.png" alt="image-20250812142045304"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812142028768.png" alt="image-20250812142028768"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812142220139.png" alt="image-20250812142220139"></p><p>自闭合没有反应</p><p>书写规范</p><ul><li>结束符：每行js代码，结尾以分号结尾，而结尾的分号可有可无。（建议在一个项目中保持一致，要么全部都加，要么全部都不加）</li><li>注释：单行注释，多行注解的写法， 与java中一致。</li></ul><table><thead><tr><th>api</th><th>描述</th></tr></thead><tbody><tr><td>window.alert(…)</td><td>警告框</td></tr><tr><td>document.write(…)</td><td>在HTML 输出内容</td></tr><tr><td>console.log(…)</td><td>写入浏览器控制台</td></tr></tbody></table><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812142559187.png" alt="image-20250812142559187"></p><p>早期还可以用var</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812142652720.png" alt="image-20250812142652720"></p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>number</td><td>数字（整数、小数、NaN(Not a Number)）</td></tr><tr><td>string</td><td>字符串，单双引(‘…’)、双引号(“…”)、反引号(<code>...</code>)皆可，正常使用推荐单引号</td></tr><tr><td>boolean</td><td>布尔。true，false</td></tr><tr><td>null</td><td>对象为空。 JavaScript 是大小写敏感的，因此 null、Null、NULL是完全不同的</td></tr><tr><td>undefined</td><td>当声明的变量未初始化时，该变量的默认值是 undefined</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        <span class="comment">//原始数据类型</span></span><br><span class="line">        <span class="title function_">alert</span>(<span class="keyword">typeof</span> <span class="number">3</span>); <span class="comment">//number</span></span><br><span class="line">        <span class="title function_">alert</span>(<span class="keyword">typeof</span> <span class="number">3.14</span>); <span class="comment">//number</span></span><br><span class="line"></span><br><span class="line">        <span class="title function_">alert</span>(<span class="keyword">typeof</span> <span class="string">&quot;A&quot;</span>); <span class="comment">//string</span></span><br><span class="line">        <span class="title function_">alert</span>(<span class="keyword">typeof</span> <span class="string">&#x27;Hello&#x27;</span>);<span class="comment">//string</span></span><br><span class="line"></span><br><span class="line">        <span class="title function_">alert</span>(<span class="keyword">typeof</span> <span class="literal">true</span>); <span class="comment">//boolean</span></span><br><span class="line">        <span class="title function_">alert</span>(<span class="keyword">typeof</span> <span class="literal">false</span>);<span class="comment">//boolean</span></span><br><span class="line"></span><br><span class="line">        <span class="title function_">alert</span>(<span class="keyword">typeof</span> <span class="literal">null</span>); <span class="comment">//object </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> a ;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="keyword">typeof</span> a); <span class="comment">//undefined</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>对于字符串类型的数据，除了可以使用双引号（”…”）、单引号（’…’）以外，还可以使用反引号 （&#96;&#96;）。 而使用反引号引起来的字符串，也称为 <strong>模板字符串</strong>。</p><ul><li><p>模板字符串的使用场景：拼接字符串和变量。</p></li><li><p>模板字符串的语法：</p><ul><li>&#96;&#96;：反引号 （英文输入模式下键盘 tab 键上方波浪线 ~ 那个键）</li><li>内容拼接时，使用 ${ } 来引用变量</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> name = <span class="string">&#x27;Tom&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> age = <span class="number">18</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;大家好, 我是新入职的&#x27;</span> + name + <span class="string">&#x27;, 今年&#x27;</span> + age + <span class="string">&#x27;岁了, 请多多关照&#x27;</span>); <span class="comment">//原始方式 , 手动拼接字符串</span></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`大家好, 我是新入职的<span class="subst">$&#123;name&#125;</span>, 今年<span class="subst">$&#123;age&#125;</span>岁了, 请多多关照`</span>); <span class="comment">//使用模板字符串方式拼接字符串</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><strong>函数（function）</strong>是被设计用来执行特定任务的代码块，方便程序的封装复用。 那我们学习函数，主要就是学习JS中函数的定义及调用的语法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> 函数名(参数<span class="number">1</span>,参数<span class="number">2.</span>.)&#123;</span><br><span class="line">    要执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为JavaScript是弱数据类型的语言，所以有如下几点需要注意：</p><ul><li><p>形参不需要声明类型，并且JS中不管什么类型都是let去声明，加上也没有意义。</p></li><li><p>返回值也不需要声明类型，直接return即可</p></li></ul><p>我们在调用add函数时，再添加2个参数，修改代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="title function_">add</span>(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>);</span><br><span class="line"><span class="title function_">alert</span>(result);</span><br></pre></td></tr></table></figure><p>览器打开，发现没有错误，并且依然弹出30，这是为什么呢？</p><p>因为在JavaScript中，函数的调用只需要名称正确即可，参数列表不管的。如上述案例，10传递给了变量a，20传递给了变量b，而30和40没有变量接受，但是不影响函数的正常调用。</p><p><strong>注意：由于JS是弱类型语言，形参、返回值都不需要指定类型。在调用函数时，实参个数与形参个数可以不一致，但是建议一致。</strong> </p><p><strong>匿名函数：</strong>是指一种没有名称的函数，由于它们没有名称，因此无法直接通过函数名来调用，而是通过变量或表达式来调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">function</span> (<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">add</span> = (<span class="params">a,b</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义对象"><a href="#自定义对象" class="headerlink" title="自定义对象"></a>自定义对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> 对象名 = &#123;</span><br><span class="line">    属性名<span class="number">1</span>: 属性值<span class="number">1</span>,</span><br><span class="line">    属性名<span class="number">2</span>: 属性值<span class="number">2</span>,</span><br><span class="line">    属性名<span class="number">3</span>: 属性值<span class="number">3</span>,</span><br><span class="line">    方法名称: <span class="keyword">function</span>(<span class="params">形参列表</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.属性名</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.方法名()</span><br></pre></td></tr></table></figure><h3 id="JSON对象"><a href="#JSON对象" class="headerlink" title="JSON对象"></a>JSON对象</h3><p><strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation，JavaScript对象标记法。JSON是通过JavaScript标记法书写的文本。其格式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;key&quot;</span>:value,</span><br><span class="line">    <span class="string">&quot;key&quot;</span>:value,</span><br><span class="line">    <span class="string">&quot;key&quot;</span>:value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<strong>key必须使用引号并且是双引号标记，value可以是任意数据类型。</strong></p><p>对象的属性的名字可加双引号</p><p><strong>JSON.stringify(…)：作用就是将js对象，转换为json格式的字符串。</strong></p><p><strong>JSON.parse(…)：作用就是将json格式的字符串，转为js对象。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3. JSON - JS对象标记法</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;itcast&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">alert</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(person)); <span class="comment">//js对象 --&gt; json字符串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> personJson = <span class="string">&#x27;&#123;&quot;name&quot;: &quot;heima&quot;, &quot;age&quot;: 18&#125;&#x27;</span>;</span><br><span class="line"><span class="title function_">alert</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(personJson).<span class="property">name</span>);</span><br></pre></td></tr></table></figure><p>在JS中，当然也存在对应的流程控制语句。常见的流程控制语句如下：</p><ul><li>if … else if … else …</li><li>switch</li><li>for</li><li>while</li><li>do…while</li></ul><p>和java一样</p><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>​<strong>DOM：Document Object Model 文档对象模型。也就是 JavaScript 将 HTML 文档的各个组成部分封装为对象。</strong></p><ul><li>Document：整个文档对象</li><li>Element：元素对象</li><li>Attribute：属性对象</li><li>Text：文本对象</li><li>Comment：注释对象</li></ul><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812143922050.png" alt="image-20250812143922050"></p><ul><li>改变 HTML 元素的内容</li><li>改变 HTML 元素的样式（CSS）</li><li>对 HTML DOM 事件作出反应</li><li>添加和删除 HTML 元素</li></ul><p><strong>DOM的核心思想：将网页的内容当做对象来处理，标签的所有属性在该对象上都可以找到，并且修改这个对象的属性，就会自动映射到标签身上。</strong></p><ul><li><p>document对象</p><ul><li>网页中所有内容都封装在document对象中</li><li>它提供的属性和方法都是用来访问和操作网页内容的，如：document.write(…)</li></ul></li><li><p>获取DOM元素对象</p></li><li><p>操作DOM对象的属性或方法 (查阅文档)</p></li><li><p><strong>我们可以通过如下两种方式来获取DOM元素。</strong></p><ul><li>根据CSS选择器来获取DOM元素，获取到匹配到的第一个元素：<code>document.querySelector(&#39;CSS选择器&#39;);</code></li><li>根据CSS选择器来获取DOM元素，获取匹配到的所有元素：<code>document.querySelectorAll(&#39;CSS选择器&#39;);</code><strong>这个返回的是列表</strong></li></ul></li></ul><p><strong>注意：获取到的所有元素，会封装到一个NodeList节点集合中，是一个伪数组（有长度、有索引的数组，但没有push、pop等数组方法）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812144211085.png" alt="image-20250812144211085"></p><h4 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h4><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812144541837.png" alt="image-20250812144541837"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812144550383.png" alt="image-20250812144550383"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">事件源.<span class="title function_">addEventListener</span>(<span class="string">&#x27;事件类型&#x27;</span>, 要执行的函数);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812150323819.png" alt="image-20250812150323819"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812150428741.png" alt="image-20250812150428741"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812150434356.png" alt="image-20250812150434356"></p><p><strong>addEventListener 与 on事件 区别:</strong> </p><ul><li><strong>on方式会被覆盖，addEventListener 方式可以绑定多次，拥有更多特性，推荐使用 addEventListener .</strong></li></ul><h4 id="隔行换色"><a href="#隔行换色" class="headerlink" title="隔行换色"></a>隔行换色</h4><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812150646932.png" alt="image-20250812150646932"></p><p>常用事件:</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812150736567.png" alt="image-20250812150736567"></p><h3 id="js表达式类型隐式转换"><a href="#js表达式类型隐式转换" class="headerlink" title="js表达式类型隐式转换"></a>js表达式类型隐式转换<img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250815124551310.png" alt="image-20250815124551310"></h3><h3 id="对象输出控制台"><a href="#对象输出控制台" class="headerlink" title="对象输出控制台"></a>对象输出控制台</h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250816152323897.png" alt="image-20250816152323897"></p><h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><p>JavaScript框架</p><p><strong>构建用户界面</strong>是指，在Vue中，可以基于数据渲染出用户看到的界面。 那这句话什么意思呢？我们来举一个例子，比如将来服务器端返回给前端的原始数据</p><p><strong>渐进式</strong></p><p>渐进式中的渐进呢，字面意思就是 “循序渐进”。Vue生态中的语法呢是非常多的，比如声明式渲染、组件系统、客户端路由（VueRouter）、状态管理（Vuex、Pinia）、构建工具（Webpack、Vite）等等</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812150910558.png" alt="image-20250812150910558"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812150946678.png" alt="image-20250812150946678"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812151006001.png" alt="image-20250812151006001"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;title&gt;Vue-快速入门&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &#123;&#123;message&#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;script type=&quot;module&quot;&gt;</span><br><span class="line">    import &#123; createApp &#125; from &#x27;https://unpkg.com/vue@3/dist/vue.esm-browser.js&#x27;</span><br><span class="line">    createApp(&#123;</span><br><span class="line">      data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          message: &#x27;Hello Vue&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).mount(&#x27;#app&#x27;)</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li><p>Vue中定义数据，必须通过data方法来定义，data方法返回值是一个对象，在这个对象中定义数据。</p></li><li><p>插值表达式中编写的变量，一定是Vue中定义的数据，如果插值表达式中编写了一个变量，但是在Vue中未定义，将会报错 。</p></li><li><p>Vue应用实例接管的区域是 ‘#app’，超出这个范围，就不受Vue控制了，所以vue的插值表达式，一定写在 <code>&lt;div id=&quot;app&quot;&gt;...&lt;/div&gt;</code> 的里面 。</p></li></ul><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td>v-for</td><td>列表渲染，遍历容器的元素或者对象的属性</td></tr><tr><td>v-bind</td><td>为HTML标签绑定属性值，如设置 href , css样式等</td></tr><tr><td>v-if&#x2F;v-else-if&#x2F;v-else</td><td>条件性的渲染某元素，判定为true时渲染,否则不渲染</td></tr><tr><td>v-show</td><td>根据条件展示某元素，区别在于切换的是display属性的值</td></tr><tr><td>v-model</td><td>在表单元素上创建双向数据绑定</td></tr><tr><td>v-on</td><td>为HTML标签绑定事件</td></tr></tbody></table><h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812151929574.png" alt="image-20250812151929574"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812151944095.png" alt="image-20250812151944095"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812152412319.png" alt="image-20250812152412319"></p><p>插值表达式不能写在属性值里面</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812152625473.png" alt="image-20250812152625473"></p><h3 id="v-bind-标签属性值动态绑定"><a href="#v-bind-标签属性值动态绑定" class="headerlink" title="v-bind 标签属性值动态绑定"></a>v-bind 标签属性值动态绑定</h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812153353918.png" alt="image-20250812153353918"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812153744977.png" alt="image-20250812153744977"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812153931518.png" alt="image-20250812153931518"></p><p>通过浏览器的开发者工具，我们可以看到如果使用 <code>v-show</code> 指令来渲染展示，所有元素都会渲染，只不过是通过控制display这个css样式，来决定元素是展示还是隐藏。</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812154033779.png" alt="image-20250812154033779"></p><p>如果使用 <code>v-if</code> 指令来渲染展示，确实是根据条件判断，是否渲染这个元素节点，条件成立才会渲染</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812154026012.png" alt="image-20250812154026012"></p><h3 id="v-model-双向数据绑定"><a href="#v-model-双向数据绑定" class="headerlink" title="v-model 双向数据绑定"></a><strong>v-model 双向数据绑定</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812154158346.png" alt="image-20250812154158346"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812161326837.png" alt="image-20250812161326837"></p><p>表单试图数据变化 &lt;&#x3D;&#x3D;&gt;数据模型变化</p><h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812161419517.png" alt="image-20250812161419517"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812161443438.png" alt="image-20250812161443438"></p><p>函数声明:</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812161929338.png" alt="image-20250812161929338"></p><h3 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812164043000.png" alt="image-20250812164043000"></p><p>ajax向后端发送请求,异步交互 </p><ul><li>“同”步：操作按严格的<strong>时间顺序</strong>执行，每一步必须等待前一步完成</li></ul><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812164348497.png" alt="image-20250812164348497"></p><ul><li>“异”步：操作可以<strong>不按固定顺序</strong>执行，不需要等待</li></ul><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812164404750.png" alt="image-20250812164404750"></p><p>FetchAPI</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data))</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error:&#x27;</span>, error));</span><br></pre></td></tr></table></figure><h3 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812164710456.png" alt="image-20250812164710456"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812165144757.png" alt="image-20250812165144757"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812165237078.png" alt="image-20250812165237078"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812165539464.png" alt="image-20250812165539464"></p><p>如果是post 请求体可以写在url加逗号后面</p><p>第三个参数是其他配置信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/api/data&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      data: &#123;&#125;,       // 服务器返回的数据（自动解析后的JSON）</span></span><br><span class="line"><span class="comment">      status: 200,    // HTTP状态码</span></span><br><span class="line"><span class="comment">      statusText: &#x27;OK&#x27;, // HTTP状态文本</span></span><br><span class="line"><span class="comment">      headers: &#123;&#125;,    // 响应头</span></span><br><span class="line"><span class="comment">      config: &#123;&#125;,     // 请求配置</span></span><br><span class="line"><span class="comment">      request: &#123;&#125;     // 原始的XMLHttpRequest对象</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812194149585.png" alt="image-20250812194149585"></p><p>异步变同步 需要等请求响应回来 不用写成功回调 async声明以后才可以写await</p><h3 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812194325669.png" alt="image-20250812194325669"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812194350923.png" alt="image-20250812194350923"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812194407842.png" alt="image-20250812194407842"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812194426328.png" alt="image-20250812194426328"></p><h2 id="Vue工程化"><a href="#Vue工程化" class="headerlink" title="Vue工程化"></a>Vue工程化</h2><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812210322974.png" alt="image-20250812210322974"></p><p>APP.vue</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812210341536.png" alt="image-20250812210341536"></p><p>第一部分定义js 第二部分页面结构html 第三部分css</p><p>​</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812210149374.png" alt="image-20250812210149374"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812210304669.png" alt="image-20250812210304669"></p><h3 id="vue的api风格"><a href="#vue的api风格" class="headerlink" title="vue的api风格"></a>vue的api风格</h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812211937657.png" alt="image-20250812211937657"></p><p>组合式没有创建组件实例,不能用this</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812212401549.png" alt="image-20250812212401549"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812212140071.png" alt="image-20250812212140071"></p><p>引入</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812212308707.png" alt="image-20250812212308707"></p><p> <img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812212335704.png" alt="image-20250812212335704"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250812212342267.png" alt="image-20250812212342267"></p><h3 id="响应式ref"><a href="#响应式ref" class="headerlink" title="响应式ref"></a>响应式ref</h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250815150038606.png" alt="image-20250815150038606"></p><h3 id="依赖引用"><a href="#依赖引用" class="headerlink" title="依赖引用"></a>依赖引用</h3><p>在Vue工程要引用比如axios依赖 </p><p>首先npm instatll axios</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250813121712063.png" alt="image-20250813121712063"></p><p>然后在js中import <img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250813121744465.png" alt="image-20250813121744465"></p><h3 id="Vue路由指南"><a href="#Vue路由指南" class="headerlink" title="Vue路由指南"></a>Vue路由指南</h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250814165100521.png" alt="image-20250814165100521"></p><ul><li><p>在main.js中配置路由实例 即路径与要访问组件的关系</p></li><li><p>设置路径链接点(在这里将访问哪个路径) router-link 在菜单组件中 可以通过开启router属性true 直接将link属性值作为路径</p></li><li><p>添加组件展示区</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">AppLayout</span>,  <span class="comment">// 应用整体布局</span></span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Home</span> &#125;,            <span class="comment">// 首页</span></span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&#x27;products&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Products</span> &#125;, <span class="comment">// 产品页</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;user&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="title class_">UserLayout</span>,</span><br><span class="line">        <span class="attr">children</span>: [</span><br><span class="line">          &#123; <span class="attr">path</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">component</span>: <span class="title class_">UserDashboard</span> &#125;,     <span class="comment">// 用户主页</span></span><br><span class="line">          &#123; <span class="attr">path</span>: <span class="string">&#x27;profile&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Profile</span> &#125;,    <span class="comment">// 用户资料</span></span><br><span class="line">          &#123; <span class="attr">path</span>: <span class="string">&#x27;settings&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Settings</span> &#125;   <span class="comment">// 设置</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 特殊独立路由（如登录页）</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/login&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Login</span> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>router-link to基本用法</p><!-- 字符串路径 --><p><router-link to="/home">首页</router-link></p><!-- 动态绑定路径 --><p><router-link :to="'/about'">关于</router-link></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250814200824827.png" alt="image-20250814200824827"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250814200852627.png" alt="image-20250814200852627"></p><p>根据index 找到访问路径 然后查router表  加载出对应的组件</p><p>嵌套路由 内部展示 Layout组件里面写<router-vew></p><p>不敲&#x2F; 比如<code>www.baidu.com</code> 后面会自动加上<code>/</code></p><p>然后访问到根路径</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250815103746774.png" alt="image-20250815103746774"></p><h4 id="router-push-‘-x2F-‘-路由跳转"><a href="#router-push-‘-x2F-‘-路由跳转" class="headerlink" title="router.push(‘&#x2F;‘)路由跳转"></a>router.push(‘&#x2F;‘)路由跳转</h4><p>vue应用组合式风格 使用路由</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250818144730684.png" alt="image-20250818144730684"></p><p>js文件使用路由 直接引入router对象 import router from 路由声明路径</p><h3 id="axios请求优化"><a href="#axios请求优化" class="headerlink" title="axios请求优化"></a>axios请求优化</h3><p>基于axios发送异步请求，直接将接口的请求地址放在组件文件 <code>.vue</code> 中。 而如果开发一个大型的项目，组件文件可能会很多很多很多，如果前端开发完毕，进行前后端联调测试了，需要修改请求地址，那么此时，就需要找到每一个 <code>.vue</code> 文件，然后挨个修改。 </p><p>为了解决上述问题，我们在前端项目开发时，通常会定义一个请求处理的工具类  - <code>src/utils/request.js</code> 。 在这个工具类中，对axios进行了封装。</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250815145059066.png" alt="image-20250815145059066"></p><p>而与服务端进行异步交互的逻辑，通常会按模块，封装在一个单独的API中，如：<code>src/api/dept.js</code></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250815145234232.png" alt="image-20250815145234232"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250815145252711.png" alt="image-20250815145252711"></p><p>在服务器中配置代理proxy的信息，并在配置代理时，执行目标服务器。 以及url路径重写的规则。</p><p>(请求路径不要写死在程序中 写在配置文件里 服务端反向代理)</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250815145359903.png" alt="image-20250815145359903"></p><h3 id="Elementplus表单校验"><a href="#Elementplus表单校验" class="headerlink" title="Elementplus表单校验"></a>Elementplus表单校验</h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250815184542570.png" alt="image-20250815184542570"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250815184554291.png" alt="image-20250815184554291"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250815184750500.png" alt="image-20250815184750500"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250815184814223.png" alt="image-20250815184814223"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250815184843323.png" alt="image-20250815184843323"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250815184916433.png" alt="image-20250815184916433"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250815185952956.png" alt="image-20250815185952956"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250815190502901.png" alt="image-20250815190502901"></p><p><strong>一个 <code>&lt;el-form-item&gt;</code> 就是一个校验单元，<code>prop</code> 是它的身份证，内部内容如何组合不影响校验逻辑。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250817171958431.png" alt="image-20250817171958431"></p><h3 id="watch监听与回调函数"><a href="#watch监听与回调函数" class="headerlink" title="watch监听与回调函数"></a>watch监听与回调函数</h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250816153921298.png" alt="image-20250816153921298"></p><p>回调函数:</p><p>执行A的时候需要等A执行再做后续A-B 这时候可以先做C 等到A执行完 执行A-B</p><p>A-B即回调函数</p><p>意思是先放着 去做别的事情等到xx时候回头做这事</p><p>watch监听响应式数据源 </p><p>可以是对象 监听对象 粗监听(只有对象引用改变才会监听到) 深监听 把第三个参数开启 <code>&#123;deep:true&#125;</code> 这样才会在对象属性一改变时候就监听到</p><p>可以监听对象专门的属性 响应式对象.value.属性名  但是第一项传入一个函数 返回监听属性的值</p><p>例子:()&#x3D;&gt;{return user.value.name}</p><p>简化 ()&#x3D;&gt;user.value.name</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250816154518984.png" alt="image-20250816154518984"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250816154542128.png" alt="image-20250816154542128"></p><h3 id="设置本地储存localstorage"><a href="#设置本地储存localstorage" class="headerlink" title="设置本地储存localstorage"></a>设置本地储存localstorage</h3><p>localstorage</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250818144510043.png" alt="image-20250818144510043"></p><p>前端请求拦截 统一读取localStorage中的token 并设置请求头加上token</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250818144640175.png" alt="image-20250818144640175"></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="打包部署"><a href="#打包部署" class="headerlink" title="打包部署"></a>打包部署</h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250818144313172.png" alt="image-20250818144313172"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IO流基础</title>
      <link href="/2025/09/07/IO%E6%B5%81/"/>
      <url>/2025/09/07/IO%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h2 id="文件对象File-创建办法"><a href="#文件对象File-创建办法" class="headerlink" title="文件对象File 创建办法"></a>文件对象<code>File</code> 创建办法</h2><ul><li>new File(<strong>文件路径字符串</strong>)</li><li>new File(<strong>父级路径文件对象,文件子路径</strong>) &#x2F;&#x2F;e:&#x2F;&#x2F;taozi这个目录构建成一个对象 然后”test.txt”这个作为子路径<strong>文件目录就可以创建出一个File对象</strong></li><li>new File(<strong>父级路径字符串,子路径字符串</strong>)</li></ul><p>注意 <strong>对象创建出来并不是说对应的文件就会生成</strong> 需要调用<code>createNewFile</code>方法 </p><p><code>/ 和\\等价</code></p><p>File里面可以判断 <code>isFile</code> <code>isDiretory</code> 是否是文件还是目录? 是否存在 <code>exists</code> </p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727000056838.png" alt="image-20250727000056838"></p><p><code>mkdir</code>创建<code>d:/taozi </code>成功</p><p>mkdirs创建<code>d:/taozi/xiaotao/tao</code>成功</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727000237500.png" alt="image-20250727000237500"></p><h2 id="四个基本类-都是抽象类"><a href="#四个基本类-都是抽象类" class="headerlink" title="四个基本类 都是抽象类"></a>四个基本类 <strong>都是抽象类</strong></h2><h2 id="FileInputStream-字节流-和FileReader的区别"><a href="#FileInputStream-字节流-和FileReader的区别" class="headerlink" title="FileInputStream 字节流 和FileReader的区别"></a>FileInputStream 字节流 和FileReader的区别</h2><p> 如果用字节流读取文本文件,会把一个字符拆开来读</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727001215812.png" alt="image-20250727001215812"></p><p>如果读取方式不对(例如一个字节一个字节来读取这样就会拆开)</p><p><strong>解决方案</strong></p><p>使用足够大小的buffer数组来存放流数据</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727001645831.png" alt="image-20250727001645831"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727001543284.png" alt="image-20250727001543284"></p><p>(FileInputStream 传路径&#x2F;文件对象)</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727001919025.png" alt="image-20250727001919025"></p><p>new String显示指定文件编码格式:</p><p>​<img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727002411570.png" alt="image-20250727002411570"></p><p>大文件: 可能内存溢出</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727002448559.png" alt="image-20250727002448559"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727002515203.png" alt="image-20250727002515203"></p><p>输出同理:</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727003919458.png" alt="image-20250727003919458"></p><hr><h2 id="输出追加问题"><a href="#输出追加问题" class="headerlink" title="输出追加问题"></a>输出追加问题</h2><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727002921148.png" alt="image-20250727002921148"></p><p>将第二个参数设置为true就可在末尾追加 <strong>不设置每次运行就是覆盖</strong></p><h2 id="字符占字节数"><a href="#字符占字节数" class="headerlink" title="字符占字节数"></a>字符占字节数</h2><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727003303530.png" alt="image-20250727003303530"></p><h2 id="FileWriter要刷新流还有注意关流"><a href="#FileWriter要刷新流还有注意关流" class="headerlink" title="FileWriter要刷新流还有注意关流"></a>FileWriter<strong>要刷新流还有注意关流</strong></h2><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727005156365.png" alt="image-20250727005156365"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727005212952.png" alt="image-20250727005212952"></p><h2 id="处理流中的套娃-gt-修饰器-x2F-装饰者模式"><a href="#处理流中的套娃-gt-修饰器-x2F-装饰者模式" class="headerlink" title="处理流中的套娃-&gt;修饰器&#x2F;装饰者模式"></a>处理流中的套娃-&gt;修饰器&#x2F;装饰者模式</h2><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727005848845.png" alt="image-20250727005848845"></p><p><strong>你可以像俄罗斯套娃一样，把多个处理流（装饰类）一层层嵌套起来，每层增加一个功能</strong>，最终组合出一个功能强大的流。</p><p><strong>关流只需关外层</strong></p><h2 id="对象流需要序列化"><a href="#对象流需要序列化" class="headerlink" title="对象流需要序列化"></a><strong>对象流需要序列化</strong></h2><p>对象实现Serializable接口</p><p>所有属性都应该是实现序列化的(如果用自定义类作为属性 <strong>该类也需要序列化</strong>)</p><p>static transient修饰不会被序列化</p><p>子类继承父类(已实现接口)会自动序列化</p><p><strong>对象-&gt;二进制数据(序列化)</strong></p><p><strong>二进制数据-&gt;对象(反序列化)</strong></p><h2 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h2><ul><li><code>System.in</code>标准输入流 编译类型 InputStream 运行类型 BufferedInputStream <strong>键盘</strong></li><li>System.out 标准输出流 PrintStream <strong>显示器</strong></li></ul><h2 id="编码格式问题引出转换流"><a href="#编码格式问题引出转换流" class="headerlink" title="编码格式问题引出转换流"></a><strong>编码格式问题</strong>引出转换流</h2><p>默认情况读取文件进来<strong>编码格式为UTF-8</strong></p><p>如果文件编码和默认读取的编码格式不一样 就会出现乱码</p><p><strong>字节流</strong>可以指定<strong>编码格式</strong> 转换流可以把字节流-&gt;<strong>字符流</strong></p><p>转换流套字节流 <strong>字节流指定编码格式</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727100726784.png" alt="image-20250727100726784"></p><p>转换流的优势在于编码指定+<strong>实时转换</strong></p><h2 id="打印流-PrintStream-输出流-与PrintWriter"><a href="#打印流-PrintStream-输出流-与PrintWriter" class="headerlink" title="打印流 PrintStream(输出流)与PrintWriter"></a>打印流 PrintStream(输出流)与PrintWriter</h2><p><code>print</code>底层是<code>write</code>方法</p><p>System.setOut可以改变打印流 (改变系统输出目的地) <strong>重定向</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727101638673.png" alt="image-20250727101638673"></p><h2 id="Properties配置类"><a href="#Properties配置类" class="headerlink" title="Properties配置类"></a>Properties<strong>配置类</strong></h2><p>键值对 <strong>不需要空格</strong></p><p><strong>空格在等号两边无所谓，但在键或值中间的空格会被保留</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727102508886.png" alt="image-20250727102508886"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250727102559206.png" alt="image-20250727102559206"></p><p>保存时候是<strong>Unicode</strong></p><p> null是注释 会变成#注释内容</p><p>如果没有key就是创建 有key就是修改 </p><p>底层是Hashtable</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>javaweb+ai</title>
      <link href="/2025/09/07/javaweb/"/>
      <url>/2025/09/07/javaweb/</url>
      
        <content type="html"><![CDATA[<h1 id="javaweb"><a href="#javaweb" class="headerlink" title="javaweb"></a>javaweb</h1><h3 id="1-http-超文本传输协议"><a href="#1-http-超文本传输协议" class="headerlink" title="1.http 超文本传输协议"></a>1.http 超文本传输协议</h3><p>(HTTP协议是规定了请求和响应数据的格式)</p><p>方法(method): </p><ul><li><p><code>GET</code> 请求 (会出现在url上面) 在浏览器地址栏上面会显示出来,在浏览器访问发送的都是GET请求</p></li><li><p><code>POST</code>请求</p></li></ul><p>请求协议<img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250725220910435.png" alt="image-20250725220910435"></p><p><del>tomcat服务器利用servlet 将请求数据封装成HttpServletRequest对象可以通过Spring的@RestController 注解找到业务类通过请求映射RequestMapping找到处理的方法将HttpServletRequest对象发送过去</del></p><p>正确理解:</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250725233009531.png" alt="image-20250725233009531"></p><p>响应</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250726001212837.png" alt="image-20250726001212837"></p><p>第一个是应该是传入响应对象 然后设置属性 (响应体要通过流的方式输出)</p><p>第二个是返回响应类 泛型设置返回数据类型 链式编程 因为每次设置完对象属性又返回该对象</p><p><strong>响应状态码和响应头通常不用手动设置</strong></p><h2 id="返回一个对象会自动转换成JSON格式"><a href="#返回一个对象会自动转换成JSON格式" class="headerlink" title="返回一个对象会自动转换成JSON格式"></a>返回一个对象会自动转换成JSON格式</h2><p>@RestController &#x3D; @Controller+@ResponseBody</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250726010100845.png" alt="image-20250726010100845"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250726010120353.png" alt="image-20250726010120353"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250726010451048.png" alt="image-20250726010451048"> </p><h2 id="Springboot中的单元测试"><a href="#Springboot中的单元测试" class="headerlink" title="Springboot中的单元测试"></a>Springboot中的单元测试</h2><p>用idea创建springboot项目会自动在src的test目录中创建好一个测试类</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250729002442304.png" alt="image-20250729002442304"></p><p>如果是自己定义就要加上<code>@SpringBootTest</code>注解</p><p>这样启动测试就会加载springboot的环境 会加载<strong>IOC</strong> <strong>容器</strong></p><p>在测试类中就可以加入@<strong>Autowired</strong> 依赖注入</p><p>注意:<strong>测试类所在包需要和引导类(启动类)所在包相同</strong></p><h2 id="Hikari（追光者）-默认的连接池"><a href="#Hikari（追光者）-默认的连接池" class="headerlink" title="Hikari（追光者） [默认的连接池]"></a>Hikari（追光者） [默认的连接池]</h2><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250729145144146.png" alt="image-20250729145144146"></p><p>从控制台输出的日志，我们也可以看出，springboot底层默认使用的数据库连接池就是 Hikari。</p><p>如果要改成其他连接池:</p><ul><li>添加依赖</li><li>在<code>application.properties</code>中修改spring.datasource.type</li></ul><h2 id="Springboot的配置文件"><a href="#Springboot的配置文件" class="headerlink" title="Springboot的配置文件"></a>Springboot的配置文件</h2><p>有两种格式,一种是:<strong>properties</strong> 另一种是:<strong>yml(yaml)</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250729145453010.png" alt="image-20250729145453010"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250729145443890.png" alt="image-20250729145443890"></p><p>yml层级结构更清晰,代码更简洁 大型项目配置推荐使用</p><h3 id="yml语法"><a href="#yml语法" class="headerlink" title="yml语法"></a>yml语法</h3><ul><li><p>大小写敏感</p></li><li><p>数值前边必须有空格，作为分隔符</p></li><li><p>使用缩进表示层级关系，缩进时，不允许使用Tab键，只能用空格（idea中会自动将Tab转换为空格）</p></li><li><p>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</p></li><li><p><code>#</code>表示注释，从这个字符一直到行尾，都会被解析器忽略</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250729145652812.png" alt="image-20250729145652812"></p><p>yml还可以定义数据格式:</p><ul><li>定义对象或Map集合</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">zhangsan</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line">  <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure><ul><li>定义数组、list或set集合</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hobby:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">java</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">game</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">sport</span></span><br></pre></td></tr></table></figure><p>注意:在<strong>yml格式</strong>的配置文件中，如果配置项的值是<strong>以 0 开头</strong>的，值需要使用 <strong>‘’</strong> 引起来，因为以<strong>0开头在yml中表示8进制的数据</strong>。</p><h2 id="Springboot配置文件优先级"><a href="#Springboot配置文件优先级" class="headerlink" title="Springboot配置文件优先级"></a>Springboot配置文件优先级</h2><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810212208084.png" alt="image-20250810212208084"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810212746181.png" alt="image-20250810212746181"></p><p>命令行优先级高一些 Program arguments</p><p><strong>Java系统属性高于配置文件</strong></p><h2 id="restful风格"><a href="#restful风格" class="headerlink" title="restful风格"></a>restful风格</h2><p><strong>RESTful API 简单概述</strong>  </p><p>RESTful（<strong>REpresentational State Transfer</strong>）是一种基于 <strong>HTTP 协议</strong> 的 API 设计风格，强调 <strong>资源（Resource）</strong> 和 <strong>统一接口（Uniform Interface）</strong>。  </p><hr><p><strong>核心特点</strong>  </p><ol><li><p><strong>资源（Resource）为中心</strong>  </p><ul><li>所有数据&#x2F;服务抽象为 <strong>资源</strong>，用 <strong>URI（名词）</strong> 表示，如：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/users        # 用户集合</span><br><span class="line">/users/1      # ID=1 的用户</span><br></pre></td></tr></table></figure></li><li><strong>推荐复数形式</strong>（如 <code>/users</code>），更符合集合概念。</li></ul></li><li><p><strong>HTTP 方法定义操作</strong>  </p><table><thead><tr><th>方法</th><th>用途</th><th>示例</th></tr></thead><tbody><tr><td><code>GET</code></td><td>获取资源</td><td><code>GET /users</code></td></tr><tr><td><code>POST</code></td><td>创建资源</td><td><code>POST /users</code></td></tr><tr><td><code>PUT</code></td><td>全量更新资源</td><td><code>PUT /users/1</code></td></tr><tr><td><code>PATCH</code></td><td>部分更新资源</td><td><code>PATCH /users/1</code></td></tr><tr><td><code>DELETE</code></td><td>删除资源</td><td><code>DELETE /users/1</code></td></tr></tbody></table></li><li><p><strong>无状态（Stateless）</strong>  </p><ul><li>每个请求必须包含所有必要信息（如 <code>token</code>），服务器不存储会话状态。</li></ul></li><li><p><strong>标准状态码（Status Code）</strong>  </p><ul><li><code>200 OK</code> - 成功  </li><li><code>201 Created</code> - 创建成功  </li><li><code>400 Bad Request</code> - 客户端错误  </li><li><code>404 Not Found</code> - 资源不存在  </li><li><code>500 Internal Error</code> - 服务端错误</li></ul></li><li><p><strong>返回 JSON&#x2F;XML 格式数据</strong>  </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ol><hr><p><strong>优点</strong>  </p><p>✅ <strong>简单直观</strong>：URI 清晰表达资源，HTTP 方法定义操作。<br>✅ <strong>跨平台</strong>：基于 HTTP，适合 Web、移动端、IoT 等。<br>✅ <strong>可缓存</strong>：利用 HTTP 缓存机制（如 <code>Cache-Control</code>）。  </p><hr><p><strong>RESTful vs 非RESTful 示例</strong>  </p><table><thead><tr><th><strong>RESTful</strong></th><th><strong>非RESTful（传统RPC风格）</strong></th></tr></thead><tbody><tr><td><code>GET /users</code></td><td><code>GET /getAllUsers</code></td></tr><tr><td><code>POST /users</code></td><td><code>POST /createUser</code></td></tr><tr><td><code>PUT /users/1</code></td><td><code>POST /updateUser?id=1</code></td></tr><tr><td><code>DELETE /users/1</code></td><td><code>GET /deleteUser?id=1</code></td></tr></tbody></table><hr><p><strong>一句话总结</strong>  </p><p><strong>RESTful &#x3D; 资源（URI） + HTTP方法（GET&#x2F;POST&#x2F;PUT&#x2F;DELETE） + 无状态 + 标准状态码</strong>，让 API 更规范、易用、可扩展。</p><h2 id="前后端联调测试"><a href="#前后端联调测试" class="headerlink" title="前后端联调测试"></a>前后端联调测试</h2><p>前端资源部署在<strong>Nginx</strong> <strong>服务器</strong> 上</p><p>后端资源部署在 <strong>Tomcat服务器</strong>上</p><h2 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx<strong>反向代理</strong></h2><ol><li><strong>正向代理（Forward Proxy）</strong></li></ol><ul><li><strong>代理的对象是客户端</strong>：正向代理代表客户端向服务器发送请求，隐藏客户端的真实身份。</li></ul><ol start="2"><li><strong>反向代理（Reverse Proxy）</strong></li></ol><ul><li><strong>代理的对象是服务器</strong>：反向代理代表服务器接收客户端的请求，隐藏服务器的真实信息（如IP、架构等）。</li></ul><p><strong>反向代理如何隐藏后端路径？</strong></p><ul><li><strong>客户端看到的路径</strong>：<br><code>https://example.com/api/users</code>（对外暴露的友好路径）。</li><li><strong>真实后端路径</strong>：<br><code>http://localhost:8080/users</code>（可能还带版本号，比如 <code>/v1/users</code>，但客户端不知道）。</li></ul><p>Nginx 在中间做“翻译”：</p><ol><li><strong>接收客户端请求</strong>：<code>/api/users</code></li><li><strong>重写路径</strong>：去掉 <code>/api/</code>，变成 <code>/users</code></li><li><strong>转发给后端</strong>：<code>http://localhost:8080/users</code></li></ol><p><strong>结果</strong>：</p><ul><li>客户端以为接口就是 <code>/api/users</code>，**不知道后端真正的路径是 <code>/users</code>**。</li><li>后端收到的是 <code>/users</code>，**不知道客户端原来请求的是 <code>/api/users</code>**（除非 Nginx 透传头信息）。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250730140416574.png" alt="image-20250730140416574"></p><h2 id="控制层接受简单前端参数-QueryString"><a href="#控制层接受简单前端参数-QueryString" class="headerlink" title="控制层接受简单前端参数(QueryString)"></a>控制层接受简单前端参数(QueryString)</h2><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250730142544011.png" alt="image-20250730142544011"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getUser</span><span class="params">(<span class="meta">@RequestParam</span> String userId)</span> &#123;</span><br><span class="line">    <span class="comment">// 等效于 @RequestParam(required=true) String userId</span></span><br><span class="line">    <span class="comment">// 如果请求不带 ?userId=xxx 参数，会直接报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收数组的情况<img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250802165538579.png" alt="image-20250802165538579"></p><p><strong>核心答案：这其实是两种完全不同的机制在起作用！<code>Integer[]</code> 能成功，恰恰证明了Spring的“按名匹配”默认规则和“类型转换”机制是如何协同工作的。</strong></p><hr><p>机制一：<code>List&lt;Integer&gt;</code> 的失败原因（复习）</p><p>当你写 <code>delete(List&lt;Integer&gt; ids)</code> 时：</p><ol><li>Spring的默认规则启动：“按名匹配，我去URL里找 <code>ids</code> 参数。”</li><li>它找到 <code>ids=&quot;1,2,3&quot;</code>（一个<strong>完整的字符串</strong>）。</li><li>它尝试将 <strong>一整个字符串</strong> <code>&quot;1,2,3&quot;</code> 塞给 <code>List&lt;Integer&gt;</code>。</li><li>Spring发现没有内置的转换器能把一个String直接转换成 <code>List&lt;Integer&gt;</code>，所以<strong>失败</strong>。</li></ol><hr><p>机制二：<code>Integer[]</code> 的成功原因（精妙之处）</p><p>当你写 <code>delete(Integer[] ids)</code> 时，过程是这样的：</p><ol><li>Spring的默认规则同样启动：“按名匹配，我去URL里找 <code>ids</code> 参数。”</li><li>它同样找到 <code>ids=&quot;1,2,3&quot;</code>（一个<strong>完整的字符串</strong>）。</li><li>关键来了：Spring有一个强大的 **<code>DefaultFormattingConversionService</code>**，它内置了大量默认的类型转换器。</li><li>这个转换器发现，目标类型是 <code>Integer[]</code>（一个数组）。它内置了将String转换为数组的规则，<strong>而这个规则恰好支持逗号分隔符！</strong></li><li>于是，转换器自动将字符串 <code>&quot;1,2,3&quot;</code> <strong>按逗号分割</strong>，得到 <code>[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</code>，然后再将每个字符串元素转换为 <code>Integer</code>，最终成功地填充到了 <code>Integer[]</code> 数组中。</li></ol><p><strong>简单来说：Spring默认就懂得如何把 <code>&quot;a,b,c&quot;</code> 这样的字符串转换成 <code>String[]</code>，而将元素转换为 <code>Integer</code> 又是另一个内置的基础功能。两者结合，就实现了 <code>&quot;1,2,3&quot;</code> -&gt; <code>Integer[]</code> 的魔法。</strong></p><hr><p>对比实验：让你彻底明白</p><p>假设URL都是 <code>/emp?ids=1,2,3</code>。</p><table><thead><tr><th align="left">你写的Controller方法参数</th><th align="left">Spring的内心活动</th><th align="left">结果</th></tr></thead><tbody><tr><td align="left"><code>List&lt;Integer&gt; ids</code></td><td align="left">“我得把 <strong>一整个</strong> 字符串 <code>&#39;1,2,3&#39;</code> 变成一个List。”</td><td align="left"><strong>失败！(绑定不上)</strong></td></tr><tr><td align="left"><strong><code>Integer[] ids</code></strong></td><td align="left">“我有招！我能把字符串 <code>&#39;1,2,3&#39;</code> <strong>按逗号拆分</strong>，再把每个部分转成Integer，塞进数组。”</td><td align="left"><strong>成功！<code>[1, 2, 3]</code></strong></td></tr><tr><td align="left"><code>@RequestParam List&lt;Integer&gt; ids</code></td><td align="left">“用户明确要求从查询参数取值，<strong>启动高级转换服务</strong>，拆分字符串并转换。”</td><td align="left"><strong>成功！<code>[1, 2, 3]</code></strong></td></tr><tr><td align="left"><code>String ids</code></td><td align="left">“这简单，直接把 <code>&#39;1,2,3&#39;</code> 这个字符串给他就行。”</td><td align="left"><strong>成功！<code>&quot;1,2,3&quot;</code></strong></td></tr><tr><td align="left"><code>List&lt;String&gt; ids</code></td><td align="left">“我得把 <strong>一整个</strong> 字符串 <code>&#39;1,2,3&#39;</code> 变成一个List。”</td><td align="left"><strong>失败！(绑定不上)</strong></td></tr></tbody></table><p>为什么会有这种“不一致”？</p><p>这更像是Spring设计历史中的一个“特性”而非“缺陷”。</p><ul><li>数组(<code>[]</code>)是Java原生语法，很早就有了，所以Spring很早就为它内置了强大的字符串拆分转换支持。</li><li><code>List</code> 是Java集合框架的一部分，Spring默认的简单类型绑定机制没有为这种复杂的泛型集合做特殊处理。<strong>你需要用 <code>@RequestParam</code> 来显式启用更高级的转换服务。</strong></li></ul><p>给你的最终建议</p><p>虽然你发现了 <code>Integer[]</code> 这个“妙用”，但**在生产环境中，我依然强烈推荐你使用 <code>@RequestParam List&lt;Integer&gt; ids</code>**。</p><p>理由如下：</p><ol><li><strong>意图清晰</strong>：明确告知阅读者，参数来自哪里。</li><li><strong>一致性</strong>：统一使用 <code>List</code> 这种集合接口，比使用原生数组 <code>[]</code> 更符合现代Java编程风格。</li><li><strong>可靠性</strong>：这是Spring官方明确支持和推荐的方式，行为最可预测，不会因为版本迭代而改变。</li><li><strong>功能完整</strong>：可以方便地配置 <code>required</code> 和 <code>defaultValue</code> 等属性。</li></ol><p>所以，你的发现很棒，它帮助你更深地理解了Spring的机制。但在实际写代码时，还是请走“官方大道”：“**要接收集合参数，请显式加上 <code>@RequestParam</code>**”。</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250806000429803.png" alt="image-20250806000429803"></p><h2 id="接受json参数"><a href="#接受json参数" class="headerlink" title="接受json参数"></a>接受json参数</h2><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250730162542228.png" alt="image-20250730162542228"></p><p> JSON格式的参数，通常会使用一个<strong>实体对象</strong>进行接收 </p><ul><li>规则：JSON数据的键名与方法形参对象的属性名相同，并需要使用<code>@RequestBody</code>注解标识。</li></ul><ol><li><p>**必须加 <code>@RequestBody</code>**：</p><ul><li>当 JSON <strong>作为请求体(body)</strong> 发送</li><li>Content-Type 为 <code>application/json</code></li></ul></li><li><p>**不需要加 <code>@RequestBody</code>**：</p><ul><li>当 JSON 作为 URL 的一部分（查询参数或路径变量）</li><li>表单提交（即使数据格式类似JSON）</li><li>任何非请求体来源的数据</li></ul></li><li><p><strong>例外情况</strong>：</p><ul><li>如果使用 <code>HttpServletRequest</code> 手动处理请求，不需要注解</li><li>如果使用 <code>@ModelAttribute</code> 接收表单数据，即使数据是JSON格式也不需要（但这不是推荐做法）</li></ul><p>如果是有规定格式的日期类型</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250731214913814.png" alt="image-20250731214913814"></p></li></ol><h2 id="接受路径参数"><a href="#接受路径参数" class="headerlink" title="接受路径参数"></a>接受路径参数</h2><p><code>/depts/1</code>，<code>/depts/2</code> 这种在url中传递的参数，我们称之为<strong>路径参数</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250730162640030.png" alt="image-20250730162640030"></p><p>如果路径参数名与controller方法形参名称一致，<code>@PathVariable</code>注解的value属性是可以省略的。</p><p><strong>不能省略</strong> <code>@PathVariable</code> 注解本身！<br>即使路径参数名与形参名一致，也必须保留 <code>@PathVariable</code> 注解，否则 Spring 会将其视为普通的请求参数（<code>@RequestParam</code>）而非路径参数。</p><h2 id="HTTP请求映射注解"><a href="#HTTP请求映射注解" class="headerlink" title="HTTP请求映射注解"></a>HTTP请求映射注解</h2><p>用于<strong>将 HTTP 请求映射到控制器方法</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250730173604307.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250730173816837.png" alt="image-20250730173816837"></p><h2 id="记录日志信息"><a href="#记录日志信息" class="headerlink" title="记录日志信息"></a>记录日志信息</h2><p>常见的日志技术</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250730175141094.png" alt="image-20250730175141094"></p><p>主要用Logback 使用接口编程 所以定义的是slf4j的属性 使用工厂得到logback</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250730175328877.png" alt="image-20250730175328877"></p><p>可以简化定义对象 用注解@<code>Slf4j</code></p><p>日志的级别:<img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250730183357023.png" alt="image-20250730183357023"></p><h2 id="开启事务的注解-Transactional"><a href="#开启事务的注解-Transactional" class="headerlink" title="开启事务的注解 @Transactional"></a>开启事务的注解<code> @Transactional</code></h2><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250801142330325.png" alt="image-20250801142330325"></p><p>加在类上会为类的每个方法开启事务 接口上就会为每一个实现类的方法开启事务</p><p>多条指令访问数据库开启事务</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250801144446633.png" alt="image-20250801144446633"></p><p>默认时只有出现运行时异常才会进行事务回滚 如果要指定异常类型可以设置 rollbackFor属性</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250801151012319.png" alt="image-20250801151012319"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250801151037633.png" alt="image-20250801151037633"></p><p>例如 无论添加员工事务有没有执行成功(提交) 都会记录操作日志</p><p>如果是加入到当前添加员工事务中 即使使用try finally (无论有没有出错都会执行finally)执行了在数据库添加操作日志 也会因为事务出错回滚rollback 因为是属于同一个事务</p><p>解决办法就是开启一个新事务 (在添加日志方法声明@Transactional注解 并且设置属性<img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250801151330750.png" alt="image-20250801151330750">)</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250801151337006.png" alt="image-20250801151337006"></p><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250801181101469.png" alt="image-20250801181101469"></p><p>前端定义成表单形式 必须设置<strong>enctype</strong>为<strong>multyipart&#x2F;form-data</strong> 不然文件的数据不会被正确发送到后端 表单请求方式是<strong>POST</strong></p><p>发送时数据不是以json格式</p><p><strong>multipart&#x2F;form-data（文件上传标准格式）</strong></p><ul><li><strong>数据格式</strong>：<br>数据被分成多个部分（parts），每个字段（文本或文件）作为独立的部分传输，用边界符（boundary）分隔。</li></ul><p>接受时候可以使用同名形参 (不同名要用 @RequestParam )</p><p>文件数据用spring提供的<strong>MultipartFile</strong> 类型的变量来接收</p><h2 id="阿里对象存储OOS"><a href="#阿里对象存储OOS" class="headerlink" title="阿里对象存储OOS"></a>阿里对象存储OOS</h2><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250907221245826.png" alt="image-20250802145218333"></p><p>设置密钥</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250907220639772.png" alt="image-20250802145734418"></p><p>灵活变通参数问题</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250802150737570.png" alt="image-20250802150737570"></p><p>可以将参数定义在yml文件中</p><p>通过@value(“”)来注入</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250802150908188.png" alt="image-20250802150908188"></p><p>注意spring的注解中(mybatis注解别搞混了)</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250802152218834.png" alt="image-20250802152218834"></p><p>但是一个一个也太麻烦了 </p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250802152240885.png" alt="image-20250802152240885">可以使用<img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250802152326726.png" alt="image-20250802152326726"></p><h2 id="全局异常处理器"><a href="#全局异常处理器" class="headerlink" title="全局异常处理器"></a>全局异常处理器</h2><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250803161538819.png" alt="image-20250803161538819"></p><p>如果要手动try-catch来捕获异常,就会很费解</p><p>现在不用管,让异常抛给框架,然后定义一个全局处理器来捕获异常(跟try catch是一样, 要先走子类的捕获)</p><p>在类上加上<code>@RestControllerAdvice</code></p><p>在方法上加上<code>@ExceptionHandler</code></p><p>比如手机号重复的场景:<br><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250803161832842.png" alt="image-20250803161832842"></p><p>getMessage()</p><p>得到异常信息 <img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250803164046437.png" alt="image-20250803164046437"></p><p>返回标准格式</p><p>Result.error </p><p>所以返回类型是<strong>Result</strong></p><h2 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术</h2><p><strong>会话（Session）的本质</strong></p><ul><li><strong>字面意思</strong>：用户打开浏览器访问网站，到关闭浏览器的整个过程（比如登录→浏览→下单→退出）</li><li><strong>技术核心</strong>：HTTP无状态，但业务需要”连续性”（比如登录后能记住你是谁）</li></ul><p><strong>会话跟踪的本质</strong></p><ul><li><strong>跟踪</strong> &#x3D; <strong>通过ID关联多次请求</strong><ul><li>像去健身房办卡：<ul><li>前台给你一张<strong>会员卡（Cookie存ID）</strong></li><li>他们用卡号<strong>查电脑记录（Session存数据）</strong></li><li>每次出示卡，他们就知道你是谁（跟踪会话）</li></ul></li></ul></li></ul><p>HTTP协议本身不会主动记住任何上下文（无状态），必须靠<strong>额外机制</strong>（如Cookie+Session）实现“记忆功能”。</p><p>addcookie(new cookie对象) <strong>自动在响应头设置响应体</strong> set-cookie: key-value</p><p>然后<strong>前端自动保存cookie</strong> 下次<strong>发送请求时候请求头自动带上</strong>cookie:key-value</p><p>后端可以读取到(但是存储在前端)</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250807151905208.png" alt="image-20250807151905208"></p><p><strong>首次请求（&#x2F;c1）时</strong>：</p><ul><li><p>服务端<strong>显式设置Cookie</strong>：</p><p>java</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.addCookie(<span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;login_username&quot;</span>, <span class="string">&quot;itheima&quot;</span>));</span><br></pre></td></tr></table></figure><p><strong>响应头</strong>：</p><p>http</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Set-Cookie: login_username=itheima; Path=/</span><br></pre></td></tr></table></figure><p><strong>第二次请求（&#x2F;c2）时</strong>：</p><ul><li><p>浏览器<strong>自动携带Cookie</strong>：</p><p>http</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /c2 HTTP/<span class="number">1.1</span></span><br><span class="line">Cookie: login_username=itheima</span><br></pre></td></tr></table></figure><p>服务端通过<code>request.getCookies()</code>读取</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250807151925883.png" alt="image-20250807151925883"></p><p>跨域 :现在基于前后端分离 比如前端部署到Nginx 后端部署到Tomcat </p><p>请求协议 ip&#x2F;域名 端口 不一样</p><p>服务端用session来存储 自动设置cookie 的id 自己存重要数据 给前端一个会员卡 存id</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250807155045307.png" alt="image-20250807155045307"></p><p><strong>首次请求（&#x2F;s1）时</strong>：</p><ul><li>调用 <code>request.getSession()</code> <strong>自动触发</strong>：<ul><li>若请求中没有 <code>JSESSIONID</code> Cookie → 创建新Session，并生成<code>JSESSIONID</code></li><li><strong>自动响应</strong>：<code>Set-Cookie: JSESSIONID=abc123</code></li></ul></li><li>你的代码通过<code>session.setAttribute()</code>存数据</li></ul><p><strong>第二次请求（&#x2F;s2）时</strong>：</p><ul><li><p>浏览器<strong>自动携带</strong>之前收到的Cookie：</p><p>http</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /s2 HTTP/<span class="number">1.1</span></span><br><span class="line">Cookie: JSESSIONID=abc123</span><br></pre></td></tr></table></figure><p>容器通过<code>JSESSIONID</code>找到之前创建的Session对象，因此能取出<code>loginUser</code></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250807160745824.png" alt="image-20250807160745824"></p><p><strong>集群</strong>:现在服务端项目部署到<strong>多台服务器</strong>上(同一个项目) 中间有一台<strong>负载均衡</strong>服务器比如Nginx 然后来根据服务器压力来决定请求交给哪一台服务器</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250807161609043.png" alt="image-20250807161609043"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250807161852870.png" alt="image-20250807161852870"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250807162407736.png" alt="image-20250807162407736"></p><p>生成令牌  存储令牌(服务端不用保存任何信息) 携带令牌 校验令牌</p><h2 id="jwt令牌"><a href="#jwt令牌" class="headerlink" title="jwt令牌"></a>jwt令牌</h2><p><strong>json-web-token</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250807200636012.png" alt="image-20250807200636012"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250807201054402.png" alt="image-20250807201054402"></p><p><strong>等号是占位的</strong></p><p>第一部分和第二部分的原始数据经过Base64编码方式变成字符串 第三部分是包含<strong>头和有效载荷</strong>以及<strong>密钥</strong> 经过<strong>签名算法</strong>生成的字符串</p><p>前面的不能改动 (篡改) 不然就校验失败 </p><p>使用方法:</p><p>创建令牌:</p><ul><li>引入依赖jjwt</li><li>调用Jwts类</li></ul><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250807201451759.png" alt="image-20250807201451759"></p><p>解析令牌:</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250807201544054.png" alt="image-20250807201544054"></p><p>Claims 继承了map接口</p><h2 id="过滤器Filter"><a href="#过滤器Filter" class="headerlink" title="过滤器Filter"></a>过滤器Filter</h2><p>Javaweb三大组件之一(<strong>Servlet,Filter,Listener</strong>)</p><p>过滤器可以拦截请求 (拦截器)</p><p>过滤器可以实现一些通用的功能(登录校验,统一编码处理,敏感字符处理)</p><p>Filter使用方法:</p><ul><li>定义Filter类,实现Filter接口,并实现其所有方法  </li><li>配置Filter 加上注解@WebFilter 配置拦截请求的路径 在引导类上(启动程序) 加上@ServletComponentScan 开启Servlet组件支持</li></ul><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250808111629426.png" alt="image-20250808111629426"></p><p>过滤器流程:</p><p>过滤请求 -放行前操作-放行-放行后操作</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250808132148309.png" alt="image-20250808132148309"></p><p>放行前操作</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250808132230169.png" alt="image-20250808132230169"></p><p>放行 交给下一个过滤器 </p><p>(放行执行过后回来 ) 执行放行后操作</p><p>Filter过滤路径 (全部路径 &#x2F;* 部分资源&#x2F;emps&#x2F;* 具体&#x2F;…)</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250808132453261.png" alt="image-20250808132453261"></p><p>过滤器顺序按字典序排优先级默认</p><h2 id="拦截器Interceptor"><a href="#拦截器Interceptor" class="headerlink" title="拦截器Interceptor"></a>拦截器Interceptor</h2><p>基于<strong>spring</strong>框架的一种动态拦截方法调用的机制 类似过滤器</p><p>用来动态拦截控制器方法的执行</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250808151624829.png" alt="image-20250808151624829"></p><p>快速入门:</p><ul><li><p><strong>自定义拦截器</strong> 实现HandlerInterceptor接口，并重写其所有方法</p></li><li><p>preHandle方法：目标资源方法执行前执行。 返回true：放行    返回false：不放行</p></li></ul><ul><li><p>postHandle方法：目标资源方法执行后执行</p></li><li><p>afterCompletion方法：视图渲染完毕后执行，最后执行(前后端分离 现在不怎么需要了)</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义拦截器</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">//目标资源方法执行前执行。 返回true：放行    返回false：不放行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;preHandle .... &quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//true表示放行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//目标资源方法执行后执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postHandle ... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//视图渲染完毕后执行，最后执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterCompletion .... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>2). 注册配置拦截器</strong></p><p>创建一个专门的包，然后创建一个配置类 <code>WebConfig</code>， 实现 <code>WebMvcConfigurer</code> 接口，并重写 <code>addInterceptors</code> 方法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义的拦截器对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DemoInterceptor demoInterceptor;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">       <span class="comment">//注册自定义拦截器对象</span></span><br><span class="line">        registry.addInterceptor(demoInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>);<span class="comment">//设置拦截器拦截的请求路径（ /** 表示拦截所有请求）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250808153122200.png" alt="image-20250808153122200"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250808153800583.png" alt="image-20250808153800583"></p><p>只用其中一个就可以了,不然就会校验两次 影响性能</p><h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><p><strong>AOP</strong>:面向切面&#x2F;方面编程 Aspect 面向特别方法编程</p><p>底层是动态代理,可以面向方法前后&#x2F;全过程执行一些共同的逻辑</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810114058587.png" alt="image-20250810114058587"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810120243750.png" alt="image-20250810120243750"></p><p>使用</p><ul><li>导入AOP依赖 有spring父级 不用手动确定版本号</li><li>编写AOP切面类 @Component交给IOC容器 @Aspect声明切面类</li></ul><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810122201554.png" alt="image-20250810122201554"></p><p><strong>AOP核心概念:</strong></p><p>AOP 底层通过动态代理（JDK Proxy 或 CGLIB）在运行时生成代理对象，<strong>拦截目标方法的调用</strong>，在方法执行的特定位置（如前置、后置、异常时）插入通知逻辑。</p><ul><li><strong>连接点:</strong> 可以被AOP控制的方法(暗含方法执行时的从相关信息)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810123246988.png" alt="image-20250810123246988"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810122624839.png" alt="image-20250810122624839"></p><ul><li><strong>通知</strong>:共性功能(重复逻辑)</li></ul><ul><li><strong>没有AOP时</strong>：每个会议组织者都要自己喊“大家先打卡！”（重复代码）。</li><li><strong>用AOP后</strong>：行政部<strong>广播通知</strong>（<code>@Before</code>通知）：“凡会议开始，自动触发打卡！”<br>→ 所有会议<strong>“都知道”这个流程</strong>，无需手动处理。</li></ul><hr><p>❓ <strong>那为什么官方不叫“广播”？</strong></p><p>因为AOP的<strong>Advice</strong>更强调<strong>“干预”</strong>而非“告知”：</p><ul><li><strong>“广播”</strong>：像发公告，接不接收随意（事件驱动模式）。</li><li><strong>“通知”</strong>：在AOP中是<strong>强制性的代码插入</strong>（比如必须验权才能调方法）。</li></ul><hr><p>✅ <strong>总结你的神理解</strong></p><ol><li><p><strong>“通知”在AOP中确实是共性代码</strong>（√ 正确）。  </p></li><li><p><strong>“所有方法都知道” ≈ AOP的代理机制</strong>（√ 本质正确）。  </p></li><li><p>唯一的小偏差：  </p><ul><li>你的理解偏向<strong>“静态共享”</strong>（像公共变量）。  </li><li>实际AOP是<strong>动态插入</strong>（运行时修改行为）。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810133036265.png" alt="image-20250810133036265"></p></li></ol><p>但没关系！程序员的世界需要这种<strong>“不严谨但生动”的比喻</strong>来降低理解门槛。下次你完全可以和别人说：<br><strong>“AOP就是把重复代码像广播一样‘通知’所有方法！”</strong> 🎤💻  </p><p><strong>AOP就是为了让一批方法（核心逻辑）无需修改就能自动应用同一套附加逻辑（通知）。</strong><br><strong>→ 和你说的“所有方法都知道要执行通知”完全</strong></p><ul><li><p><strong>切入点:</strong> 真正控制的方法 <strong>从这些方法下手，插入新逻辑</strong><br><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810133359155.png" alt="image-20250810133359155"></p></li><li><p>**切面: ** <strong>通知与切入点的联系</strong></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810133940264.png" alt="image-20250810133940264"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810134025539.png" alt="image-20250810134025539"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810134014332.png" alt="image-20250810134014332"></p><p> <strong>为什么叫“切面”？</strong></p><ul><li><strong>“切”</strong> &#x3D; 横向选中一批方法（通过切入点）。</li><li><strong>“面”</strong> &#x3D; 这些方法 + 通知逻辑的<strong>组合关系</strong>。</li><li><strong>合起来</strong>：<strong>“通过规则把代码和增强逻辑绑定的方案”</strong>。</li></ul><ol><li><strong>切面 &#x3D; 切入点 + 通知的封装</strong>（就像一份“增强说明书”）。</li><li><strong>它不主动生效</strong>，而是由AOP框架在运行时<strong>动态应用</strong>到匹配的方法上。</li><li><strong>最终效果</strong>：所有符合切入点的方法，调用时自动执行通知逻辑。</li></ol><p>下次可以简单说：<br><strong>“切面就是告诉AOP：哪些方法（切入点）要自动加什么功能（通知）！”</strong> 🎯</p><p><strong>目标对象:</strong> 通知所应用的对象</p><p>通知类型:</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810135753369.png" alt="image-20250810135753369"></p><p>@Pointcut注解 抽取公共切入点表达式</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810135852854.png" alt="image-20250810135852854"></p><p>对于返回值问题:</p><ol><li><p><strong>动态代理的本质</strong>：  </p><ul><li>所有方法调用（包括<code>void</code>方法）<strong>底层都必须返回一个值</strong>（<code>void</code>方法实际返回<code>null</code>）。  </li><li><strong>代理对象</strong>（比如Spring AOP生成的代理）<strong>必须处理这个返回值</strong>，否则JVM会报错。</li></ul></li><li><p><strong>Spring的“偷懒”设计</strong>：  </p><ul><li>对于<code>@Before</code>、<code>@After</code>等通知，Spring说：<strong>“你只管写你的逻辑（<code>void</code>），返回值的麻烦事我来帮你搞定！”</strong>  <ul><li>比如你写<code>@Before</code>，Spring会在代理中自动调用你的代码，然后<strong>替你返回正确的值</strong>（原方法的返回值或<code>null</code>）。</li></ul></li></ul></li><li><p><strong><code>@Around</code>的特殊性</strong>：  </p><ul><li><code>@Around</code>是<strong>全能管家</strong>，Spring说：<strong>“你要自己控制一切（包括返回值），我不帮你兜底！”</strong>  <ul><li>你必须手动调用<code>proceed()</code>（相当于执行原方法），并<strong>自己返回一个值</strong>（哪怕是<code>null</code>）。  </li><li>因为<code>@Around</code>可以<strong>修改返回值</strong>（比如把<code>null</code>改成<code>&quot;成功&quot;</code>），所以Spring无法自动处理。</li></ul></li></ul></li></ol><hr><p><strong>类比：餐厅点餐</strong></p><ul><li><p><strong>普通通知（<code>@Before</code>&#x2F;<code>@After</code>）</strong>：  </p><ul><li>像服务员，只负责记录订单或清理桌子（不需要决定最终上什么菜）。  </li><li><strong>厨房（Spring）</strong>会自动把菜端给顾客（处理返回值）。</li></ul></li><li><p>**<code>@Around</code>**：  </p><ul><li>像厨师长，<strong>亲自做菜</strong>（调用<code>proceed()</code>），还能<strong>改菜谱</strong>（替换返回值）。  </li><li>必须自己把菜端出去（<code>return result</code>），不能甩锅给服务员！</li></ul></li></ul><hr><p><strong>代码对比</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通通知：Spring自动处理返回值</span></span><br><span class="line"><span class="meta">@Before(&quot;execution(* orderFood(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;服务员：记录订单&quot;</span>); <span class="comment">// 不需要返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @Around：必须自己处理返回值</span></span><br><span class="line"><span class="meta">@Around(&quot;execution(* orderFood(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">aroundOrder</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;厨师长：开始做菜&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> pjp.proceed(); <span class="comment">// 做菜（可能返回null或实际值）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;加辣的&quot;</span> + result; <span class="comment">// 必须自己返回！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>最终结论</strong></p><ul><li><strong>动态代理</strong>：强制所有方法返回<code>Object</code>（<code>void</code>返回<code>null</code>）。  </li><li><strong>Spring</strong>：  <ul><li>对普通通知（<code>@Before</code>等）<strong>隐藏返回值细节</strong>（让你写<code>void</code>）。  </li><li>对<code>@Around</code><strong>要求显式返回</strong>（因为你要完全控制流程）。</li></ul></li></ul><p><strong>简单说</strong>：<code>@Around</code>是老板，其他通知是员工，Spring是行政助理——老板得亲力亲为，员工可以偷懒！ 😄</p><p>通知执行的顺序:</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810151910593.png" alt="image-20250810151910593"></p><p>1</p><p>2</p><p>3</p><p>3</p><p>2</p><p>1</p><p><strong>切入点表达式:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810152050203.png" alt="image-20250810152050203"></p><p>可以加上|| &amp;&amp; ! 在复杂情况的时候</p><p>此外 还可以用注解来定位切入点</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810152441097.png" alt="image-20250810152441097"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810152503537.png" alt="image-20250810152503537"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810152520025.png" alt="image-20250810152520025"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810152532559.png" alt="image-20250810152532559"></p><p><strong>连接点</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810152557324.png" alt="image-20250810152557324"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810152925689.png" alt="image-20250810152925689"></p><h2 id="线程变量"><a href="#线程变量" class="headerlink" title="线程变量"></a>线程变量</h2><p><strong>ThreadLocal</strong></p><p>每个线程都有一个变量,ThreadLocalMap </p><p>Key-ThreadLocal value 就是ThreadLocal.set(value)</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810172313671.png" alt="image-20250810172313671"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810172337188.png" alt="image-20250810172337188"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250810172402724.png" alt="image-20250810172402724"></p><p><strong>ThreadLocal 三件套工作原理</strong></p><p><strong>1. <code>set(T value)</code> 方法</strong></p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">    Thread t = Thread.currentThread();          // 1. 获取当前线程对象</span><br><span class="line">    ThreadLocalMap map = t.threadLocals;        // 2. 获取线程的ThreadLocalMap</span><br><span class="line">    if (map != null) &#123;</span><br><span class="line">        map.set(this, value);                  // 3a. 存在Map：直接存储（this作Key）</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        createMap(t, value);                   // 3b. 不存在Map：初始化</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点：</strong></p><ul><li><code>this</code> 是当前 <code>ThreadLocal</code> 对象，作为 Map 的 Key</li><li><code>createMap()</code> 底层：<code>t.threadLocals = new ThreadLocalMap(this, firstValue)</code></li></ul><p><strong>2. <code>get()</code> 方法</strong></p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">    Thread t = Thread.currentThread();          // 1. 获取当前线程</span><br><span class="line">    ThreadLocalMap map = t.threadLocals;        // 2. 获取线程的Map</span><br><span class="line">    if (map != null) &#123;</span><br><span class="line">        Entry e = map.getEntry(this);           // 3a. 用this查找Entry</span><br><span class="line">        if (e != null) &#123;</span><br><span class="line">            return (T)e.value;                  // 找到则返回值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return setInitialValue();                   // 3b. 不存在返回null（默认）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>隐藏逻辑：</strong></p><ul><li><code>setInitialValue()</code> 内部会调用 <code>initialValue()</code>（可重写该方法设置默认值）</li></ul><p><strong>3. <code>remove()</code> 方法</strong></p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void remove() &#123;</span><br><span class="line">    ThreadLocalMap m = Thread.currentThread().threadLocals;</span><br><span class="line">    if (m != null) &#123;</span><br><span class="line">        m.remove(this);                         // 用this删除对应Entry</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么要显式 remove？</strong></p><ul><li>避免内存泄漏（Entry的Key是弱引用，但Value是强引用）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class UserContext &#123;</span><br><span class="line">    // 静态全局变量</span><br><span class="line">    private static final ThreadLocal&lt;User&gt; holder = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    // 存储用户信息</span><br><span class="line">    public static void setUser(User user) &#123;</span><br><span class="line">        holder.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取用户信息</span><br><span class="line">    public static User getUser() &#123;</span><br><span class="line">        return holder.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 清理</span><br><span class="line">    public static void clear() &#123;</span><br><span class="line">        holder.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用示例</span><br><span class="line">try &#123;</span><br><span class="line">    UserContext.setUser(currentUser);  // 拦截器/过滤器存入</span><br><span class="line">    doSomething();                    // 业务代码中随时获取</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    UserContext.clear();              // 确保清理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JDK8新特性</title>
      <link href="/2025/09/07/JDK8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2025/09/07/JDK8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h1><h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><ul><li><p>速度更快</p></li><li><p><strong>代码更少(lambda表达式语法糖)</strong></p></li><li><p><strong>Stream API 工厂</strong></p></li><li><p>便于并行</p></li><li><p>空指针异常避免 Optional容器类 (可能为空)</p></li></ul><h3 id="速度更快"><a href="#速度更快" class="headerlink" title="速度更快"></a>速度更快</h3><ul><li>hashmap 从数组加链表 -&gt;数组 链表红黑树</li><li>垃圾回收机制内存结构(<strong>元空间metaspace</strong>(方法区 不再划分为堆中的永久区)<strong>直接使用物理内存</strong> 给多少用多少 )  最大的不同</li></ul><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250903235946480.png" alt="image-20250903235946480"></p><p>方法区原本是永久区的一部分,现在已经从永久区剥离出来</p><p>方法区加载类信息 会被垃圾回收机制回收,回收条件苛刻</p><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>一个匿名函数,可以传递的代码</p><p>引入例子:</p><p><strong>(传统方法-&gt;策略模式 -&gt;匿名内部类-&gt;lambda表达式)</strong></p><p>实现Comparator比较器中的compare方法 只关心compare方法 但是新建一个比较器匿名类来传递 </p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904000528414.png" alt="image-20250904000528414"></p><p>实际有用的代码就是compare方法里面返回的那一个语句</p><p>例子2:获取公司中35岁以上员工的信息</p><ul><li><p>员工类</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904001009898.png" alt="image-20250904001009898"></p><p>需求改变 :工资大于5000</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904001045916.png" alt="image-20250904001045916"></p></li></ul><p>代码冗余 </p><p>想到设计模式来优化</p><p>创建一个接口</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904001321809.png" alt="image-20250904001321809"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904001410331.png" alt="image-20250904001410331"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904001701578.png" alt="image-20250904001701578"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904001722821.png" alt="image-20250904001722821"></p><p>策略设计模式:设计一个接口 大家各自实现同一方法 然后调用统一</p><p>再优化,不用单独设计一个实现类,直接传接口的匿名内部类</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904001913352.png" alt="image-20250904001913352"></p><p>引出Lambda表达式</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904002050245.png" alt="image-20250904002050245"></p><p>再优化引出Stream API 对集合创建流:</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904002345569.png" alt="image-20250904002345569"></p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法:"></a>基本语法:</h4><p>JDK新引入的操作符”-&gt;” 箭头操作符 或者  lambda操作符</p><p>箭头左侧是 lambda表达式的参数列表 箭头右侧是lambda表达式中执行的功能 (lambda体)</p><p>lambda表达式 对接口的实现</p><p>参数列表对应接口抽象方法的参数  右侧抽象方法实现</p><p>接口中只能有一个抽象方法</p><p>引出 函数式接口</p><h4 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式:"></a>语法格式:</h4><ul><li><strong>无参 无返回</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250726113321554.png" alt="image-20250726113321554"></p><p>num这个变量在匿名内部类中是final的 1.7前 要显示声明,JDK8不需要 会自动补上</p><ul><li><strong>一参无返回</strong></li></ul><p>Comsumer接口 </p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904110215579.png" alt="image-20250904110215579"></p><p>一个参数,无返回值</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904110325613.png" alt="image-20250904110325613"></p><ul><li>只有一个参数的话,<strong>参数的小括号可以省略不写</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904110408334.png" alt="image-20250904110408334"></p><ul><li>**多个参数,lambda体有多条语句 **{}不能省略</li></ul><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904110514536.png" alt="image-20250904110514536"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904110547204.png" alt="image-20250904110547204"></p><ul><li><p><strong>lambda体中只有一条语句,{}可以省略,return也可以省略</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904110702509.png" alt="image-20250904110702509"></p></li><li><p>lambda的<strong>形参列表的数据类型可以不写</strong>,要写的话全部都要写**,不写的话可以根据上下文自动推断**</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904124733912.png" alt="image-20250904124733912"></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904111017270.png" alt="image-20250904111017270"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904112003711.png" alt="image-20250904112003711"></p><p>当分开写时，编译器在赋值语句 <code>strs = &#123;...&#125;</code> 这里无法推断 <code>&#123;&#125;</code> 应该是什么类型。编译器看到 <code>&#123;&#125;</code> 不知道这是 <code>String[]</code>、<code>Object[]</code> 还是其他类型。</p><p>右边&lt;&gt;不写可以自动推断</p><p>在1.7中推断不出</p><p>​</p><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>lambda表达式需要函数式接口(接口中只有一个抽象方法) <code>@FunctionalInterface</code> 声明函数式接口 可以检查是否是函数式接口</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904125239113.png" alt="image-20250904125239113"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904125146722.png" alt="image-20250904125146722"></p><h4 id="Java内置函数式接口"><a href="#Java内置函数式接口" class="headerlink" title="Java内置函数式接口"></a>Java内置函数式接口</h4><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904125442905.png" alt="image-20250904125442905"></p><p>有去无回</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904130502584.png" alt="image-20250904130502584"></p><p>无私奉献</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904130550334.png" alt="image-20250904130550334"></p><p>处理字符串</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904130855268.png" alt="image-20250904130855268"></p><p>筛选字符串</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904131137658.png" alt="image-20250904131137658"></p><h4 id="其他内置函数式接口"><a href="#其他内置函数式接口" class="headerlink" title="其他内置函数式接口"></a>其他内置函数式接口</h4><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904131306194.png" alt="image-20250904131306194"></p><h3 id="方法引用和构造器引用"><a href="#方法引用和构造器引用" class="headerlink" title="方法引用和构造器引用"></a>方法引用和构造器引用</h3><h4 id="方法引用-函数式接口中方法返回值和参数类型与引用方法的返回值和参数类型保持一致"><a href="#方法引用-函数式接口中方法返回值和参数类型与引用方法的返回值和参数类型保持一致" class="headerlink" title="方法引用 (函数式接口中方法返回值和参数类型与引用方法的返回值和参数类型保持一致)"></a>方法引用 (函数式接口中方法返回值和参数类型与<strong>引用方法</strong>的返回值和参数类型保持一致)</h4><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904132537922.png" alt="image-20250904132537922"></p><p>  <strong><code>对象::实例方法名</code></strong></p><p> <img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904132231871.png" alt="image-20250904132231871"></p><p><strong><code>类::静态方法名</code></strong></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904132329994.png" alt="image-20250904132329994"></p><p><strong><code>类::实例方法名</code></strong></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904133039972.png" alt="image-20250904133039972"></p><p>x实例方法 euqals </p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250726135124140.png" alt="image-20250726135124140"></p><h4 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h4><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250726135917279.png" alt="image-20250726135917279"></p><p>supplier中的get是无参有返回 对应Employee中的无参构造器</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250726140028854.png" alt="image-20250726140028854"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250726140301119.png" alt="image-20250726140301119"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250726140105251.png" alt="image-20250726140105251"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904134849584.png" alt="image-20250904134849584"></p><h4 id="数组引用"><a href="#数组引用" class="headerlink" title="数组引用"></a>数组引用</h4><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904135002980.png" alt="image-20250904135002980"></p><p>太有意思了 数组也是类</p><h3 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250726153046931.png" alt="image-20250726153046931"></p><p>Stream操作对象是集合 然后不会对数据源(集合) 产生影响 </p><p>会产生一个新流</p><p>流水线(过滤,切片…)</p><p>就像数据预览 </p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904140606050.png" alt="image-20250904140606050"></p><h4 id="创建流"><a href="#创建流" class="headerlink" title="创建流:"></a>创建流:</h4><p>四种方式:</p><p>(串行流和并行流)</p><h5 id="串行流与并行流"><a href="#串行流与并行流" class="headerlink" title="串行流与并行流"></a>串行流与并行流</h5><p><strong>流处理的中间操作顺序决定了每个元素的计算逻辑  pipeline（如先 filter 再  map），这个逻辑顺序在串行和并行流中均严格保持不变。然而，串行流会严格按照源数据顺序依次执行每个元素的所有操作，从而保证最终结果有序；而并行流则将数据分片后并行处理，虽然每个分片内的元素依然遵循先 filter 后 map  的操作顺序，但不同分片的执行进度快慢不一，导致元素的处理完成顺序和最终结果的收集顺序变得不可预测。因此，选择串行还是并行的核心权衡在于：是优先保证结果顺序的确定性，还是优先追求大数据集的处理速度。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904141352449.png" alt="image-20250904141352449"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904141851289.png" alt="image-20250904141851289"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904141433946.png" alt="image-20250904141433946"></p><p>一元运算符 传进去的和出来的类型一致</p><p>对seed进行操作产生新流 (一直迭代 (无穷))</p><ul><li>✅ 一元运算符确实要求输入输出类型一致</li><li>✅ 无限流从seed开始，通过一元运算符不断迭代</li><li>⚠️ 但实际使用时需要限制操作，否则真的会”无限”</li></ul><p>创建Stream以后可以进行一系列的中间操作,然后用终止操作停止</p><h4 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作:"></a>中间操作:</h4><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904152048813.png" alt="image-20250904152048813"></p><h4 id="惰性求值特性"><a href="#惰性求值特性" class="headerlink" title="惰性求值特性"></a>惰性求值特性</h4><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904230119217.png" alt="image-20250904230119217"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904230507307.png" alt="image-20250904230507307"></p><h4 id="内部迭代和外部迭代-内部迭代就是中间操作的细节不知道-只是给了声明要这样做-外部迭代是清楚迭代要做什么由你主导-每个命令都是你写"><a href="#内部迭代和外部迭代-内部迭代就是中间操作的细节不知道-只是给了声明要这样做-外部迭代是清楚迭代要做什么由你主导-每个命令都是你写" class="headerlink" title="内部迭代和外部迭代 (内部迭代就是中间操作的细节不知道,只是给了声明要这样做  外部迭代是清楚迭代要做什么由你主导 每个命令都是你写 )"></a>内部迭代和外部迭代 (内部迭代就是中间操作的细节不知道,只是给了声明要这样做  外部迭代是清楚迭代要做什么由你主导 每个命令都是你写 )</h4><h4 id="筛选与切片"><a href="#筛选与切片" class="headerlink" title="筛选与切片:"></a>筛选与切片:</h4><h5 id="过滤filter"><a href="#过滤filter" class="headerlink" title="过滤filter"></a>过滤filter</h5><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904230804733.png" alt="image-20250904230804733"></p><h5 id="截断limit"><a href="#截断limit" class="headerlink" title="截断limit"></a>截断limit</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">employees.stream()                    <span class="comment">// 开始遍历源数据</span></span><br><span class="line">    .filter((e) -&gt; &#123;                 <span class="comment">// 每个元素都经过这里</span></span><br><span class="line">        System.out.println(<span class="string">&quot;短路!&quot;</span>);  <span class="comment">// 每个都执行（您的&quot;还是遍历&quot;）</span></span><br><span class="line">        <span class="keyword">return</span> e.getSalary() &gt; <span class="number">5000</span>; <span class="comment">// 不满足的被过滤（您的&quot;被过滤了&quot;）</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .limit(<span class="number">2</span>)                        <span class="comment">// 找到2个就停止（您的&quot;贪心&quot;）</span></span><br><span class="line">    .forEach(System.out::println);   <span class="comment">// 只处理最终结果（您的&quot;就进行这两个&quot;）</span></span><br></pre></td></tr></table></figure><h5 id="跳过skip"><a href="#跳过skip" class="headerlink" title="跳过skip"></a>跳过skip</h5><p>跟limit互补,不要前几个</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904231949535.png" alt="image-20250904231949535"></p><h5 id="去重distinct"><a href="#去重distinct" class="headerlink" title="去重distinct"></a>去重distinct</h5><p><strong>要重新hashCode()和equals()方法</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250904232133331.png" alt="image-20250904232133331"></p><h4 id="映射"><a href="#映射" class="headerlink" title="映射:"></a>映射:</h4><h5 id="map和flatmap"><a href="#map和flatmap" class="headerlink" title="map和flatmap"></a>map和flatmap</h5><p>提供一个Function 输入返回 输入这些源 然后映射成返回值</p><p>然后调用apply方法</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250905123152739.png" alt="image-20250905123152739"></p><p>这里就是给了一个将list里面的每个字符串单独转换成一个流 Stream<Character> 类型是字符 包装类</p><p>用的是类:: 静态方法 方法引用 传进map里面去  然后这个流里面的数据就都是流了</p><p>这时候用flatmap 可以将流铺平(二维转一维) 即</p><p>[1,2,3,4,[5,6],[7,8]]</p><p>铺平后变成</p><p>[1,2,3,4,5,6,7,8]</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250905123756728.png" alt="image-20250905123756728"></p><p>本来是流套流</p><p>现在是把流数据全部拼接 (降维)</p><p>补充: (类似的) add和addall的区别 add简单拼接 addall是拼接元数据</p><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>sorted()自然排序 按照Comparable 接口中实现的compareto方法的规则来排序</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250905124801778.png" alt="image-20250905124801778"></p><p>sorted(Comparator )传入一个比较器来排序</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250905125543408.png" alt="image-20250905125543408"></p><h4 id="终止操作"><a href="#终止操作" class="headerlink" title="终止操作:"></a>终止操作:</h4><h5 id="查找与匹配"><a href="#查找与匹配" class="headerlink" title="查找与匹配"></a>查找与匹配</h5><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250905125705362.png" alt="image-20250905125705362"></p><p>allMatch就是判断全部元素是否都匹配</p><p>anyMatch有就满足</p><p>noneMatch所有都不匹配才成功</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250726185617004.png" alt="image-20250726185617004"></p><p>Optional容器类解决空指针异常</p><p>有可能找不到 为空</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250905130736248.png" alt="image-20250905130736248"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250905130808178.png" alt="image-20250905130808178"></p><p>默认是升序排,加负号就降序了</p><h5 id="归约reduce"><a href="#归约reduce" class="headerlink" title="归约reduce"></a>归约reduce</h5><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250905134300222.png" alt="image-20250905134300222"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250905134015066.png" alt="image-20250905134015066"></p><p>给定一个起始值,然后用二元运算反复结合</p><p>例如起始值0 ,(x,y)-&gt;x+y 然后就是累加效果 x是现有值 然后y就是加进来的值 然后计算结果赋给x</p><p>如果没有起始值的话,用Optional防止空指针</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250905134216518.png" alt="image-20250905134216518"></p><p>map-reduce模式 比如猜你喜欢 map来映射成 键值对 统计次数 规约然后汇总 然后就知道搜索次数 并行</p><h5 id="收集collect"><a href="#收集collect" class="headerlink" title="收集collect"></a>收集collect</h5><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250905144520940.png" alt="image-20250905144520940"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250726215852925.png" alt="image-20250726215852925"></p><p>Collectors.joining提供了字符串连接</p><h3 id="Java-8-默认方法：类优先与接口冲突"><a href="#Java-8-默认方法：类优先与接口冲突" class="headerlink" title="Java 8 默认方法：类优先与接口冲突"></a>Java 8 默认方法：类优先与接口冲突</h3><hr><h5 id="知识点一：接口中的默认方法与“类优先”原则"><a href="#知识点一：接口中的默认方法与“类优先”原则" class="headerlink" title="知识点一：接口中的默认方法与“类优先”原则"></a>知识点一：接口中的默认方法与“类优先”原则</h5><ul><li>Java 8 允许接口用 <code>default</code> 关键字定义<strong>有方法体的方法</strong>，叫<strong>默认方法</strong>。</li><li>当一个类<strong>继承父类</strong>又<strong>实现接口</strong>时：<ul><li>如果父类和接口都有同名方法 → <strong>优先用父类的方法</strong>。</li><li>叫做“<strong>类优先</strong>”原则。</li></ul></li></ul><hr><h5 id="知识点二：接口冲突与解决方法"><a href="#知识点二：接口冲突与解决方法" class="headerlink" title="知识点二：接口冲突与解决方法"></a>知识点二：接口冲突与解决方法</h5><ul><li><p>一个类实现多个接口，如果这些接口有<strong>同名的默认方法</strong> → 发生<strong>接口冲突</strong>。</p></li><li><p>Java 不知道选哪个，会<strong>编译报错</strong>。</p></li><li><p>解决办法：在类中<strong>重写该方法</strong>，并可使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接口名.<span class="built_in">super</span>.方法名();</span><br></pre></td></tr></table></figure><p>来调用指定接口的默认实现。</p></li></ul><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>外卖</title>
      <link href="/2025/09/07/sky-take-out/"/>
      <url>/2025/09/07/sky-take-out/</url>
      
        <content type="html"><![CDATA[<h1 id="外卖"><a href="#外卖" class="headerlink" title="外卖"></a>外卖</h1><h2 id="开发介绍"><a href="#开发介绍" class="headerlink" title="开发介绍:"></a>开发介绍:</h2><h3 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h3><ul><li><strong>需求分析</strong>:需求规格说明书,产品原型(静态网页)</li><li><strong>设计</strong>: UI设计(界面效果,人机交互逻辑) 数据库设计 接口设计(请求,响应规范)</li><li><strong>编码</strong>: 项目代码,单元测试</li><li><strong>测试</strong>:测试用例,测试报告</li><li><strong>上线运维</strong>:软件环境安装,配置</li></ul><p>角色分工:</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250820105704327.png" alt="image-20250820105704327"></p><h3 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h3><p><strong>开发环境</strong>:开发人员开发阶段使用环境,一般外部人员无法访问</p><p><strong>测试环境</strong>:测试人员使用的环境,测试项目,一般外部人员无法访问</p><p><strong>生产环境</strong>:线上环境,正式对外提供服务的环境(项目正式上线)</p><h2 id="项目整体"><a href="#项目整体" class="headerlink" title="项目整体:"></a>项目整体:</h2><p><strong>项目功能架构</strong>:(项目业务模功能模块)</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250820111123129.png" alt="image-20250820111123129">&#96;</p><p><strong>产品原型</strong></p><p><strong>技术选型</strong>:项目的技术框架和中间件</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250820111239493.png" alt="image-20250820111239493"></p><p>项目结构介绍:</p><h3 id="使用分模块开发"><a href="#使用分模块开发" class="headerlink" title="使用分模块开发"></a>使用分模块开发</h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250820123012750.png" alt="image-20250820123012750"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250820122721988.png" alt="image-20250820122721988"></p><h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段:"></a>准备阶段:</h2><h3 id="登录模块"><a href="#登录模块" class="headerlink" title="登录模块"></a>登录模块</h3><p>修改配置文件中数据库配置</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250821152138400.png" alt="image-20250821152138400"></p><p>使用阿里的德鲁伊连接池</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250821152418314.png" alt="image-20250821152418314"></p><p>从配置文件中取值</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250821152712816.png" alt="image-20250821152712816"></p><p>这段YAML配置代码用于设置Spring Boot应用的激活配置文件。spring.profiles.active: dev表示当前激活名为dev的配置文件，通常对应开发环境的配置。</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250821152739749.png" alt="image-20250821152739749"></p><p>mybatis中的mapper.xml文件映射</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250821152836267.png" alt="image-20250821152836267"></p><p>因为不是同包所以配置</p><p>全局异常捕获 (运行时异常) </p><p>将checkedException转为RuntimeException抛出</p><p>前者需要显示处理后者不需要,最后交给全局异常处理器捕获</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250821155013346.png" alt="image-20250821155013346"></p><h3 id="建造者模式-Builder"><a href="#建造者模式-Builder" class="headerlink" title="建造者模式@Builder"></a>建造者模式@Builder</h3><p>@Builder 建造者设计模式 用lombok的@Builder注解</p><p>在实体类加上@Builder注解</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250821155547628.png" alt="image-20250821155547628"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">手动实现版:</span><br><span class="line">public class User &#123;</span><br><span class="line">    private final String name;</span><br><span class="line">    private final int age;</span><br><span class="line">    private final String email;</span><br><span class="line"></span><br><span class="line">    private User(UserBuilder builder) &#123;</span><br><span class="line">        this.name = builder.name;</span><br><span class="line">        this.age = builder.age;</span><br><span class="line">        this.email = builder.email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class UserBuilder &#123;</span><br><span class="line">        private String name;</span><br><span class="line">        private int age;</span><br><span class="line">        private String email;</span><br><span class="line"></span><br><span class="line">        public UserBuilder name(String name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public UserBuilder age(int age) &#123;</span><br><span class="line">            this.age = age;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public UserBuilder email(String email) &#123;</span><br><span class="line">            this.email = email;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public User build() &#123;</span><br><span class="line">            return new User(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250821155650527.png" alt="image-20250821155650527"></p><p>外卖中用builder快速构造一个vo对象(视图对象)</p><p>密码校验方式:(根据用户名查询 然后来处理不同异常情况)</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250821155801399.png" alt="image-20250821155801399"></p><p>令牌校验,用拦截器</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250821160112427.png" alt="image-20250821160112427"></p><p>实现目标资源方法执行前的处理</p><p>定义了很多常量类</p><p>例如</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250821160451713.png" alt="image-20250821160451713"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250821160400449.png" alt="image-20250821160400449"></p><h3 id="Nginx代理服务器"><a href="#Nginx代理服务器" class="headerlink" title="Nginx代理服务器"></a>Nginx代理服务器</h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250821161043194.png" alt="image-20250821161043194"></p><p>请求过的资源会做缓存,下一次就不用重复请求服务器了</p><p>集群部署会根据服务器压力来分配请求</p><p>走nginx入口再决定走内网转发到后端服务</p><p> <img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250821161454839.png" alt="image-20250821161454839"></p><p>匹配&#x2F;api&#x2F;的部分</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250821161520153.png" alt="image-20250821161520153"></p><p>配置负载均衡</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250821161557307.png" alt="image-20250821161557307"></p><h3 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250821161731344.png" alt="image-20250821161731344"></p><hr><p>🔁 <strong>1. 轮询（Round Robin）</strong></p><ul><li><strong>就是你一次我一次</strong>：比如有3台服务器，第1个请求给服务器A，第2个给B，第3个给C，第4个又循环给A。</li><li><strong>适合场景</strong>：所有服务器性能差不多，且请求均匀。这是<strong>默认策略</strong>，但并非真正的“平均分配”，如果请求处理时间差异大，仍可能出现负载不均。</li></ul><hr><p>⚖️ <strong>2. 权重（Weight）</strong></p><ul><li><strong>给你设置重要程度</strong>：比如服务器A权重&#x3D;3，B权重&#x3D;1，那么每4个请求中，A处理3个，B处理1个。</li><li><strong>适用场景</strong>：服务器性能不一致（性能高的权重高）。</li></ul><hr><p>🌐 <strong>3. IP哈希（ip_hash）</strong></p><ul><li><strong>根据客户端IP映射一台服务器</strong>：对客户端IP计算哈希值，然后根据哈希值决定分给哪台服务器。<strong>同一个IP的请求永远固定访问同一台服务器</strong>（除非服务器宕机）。</li><li><strong>适用场景</strong>：需要会话保持（Session保持），比如用户登录后，后续操作都要到同一台服务器。</li></ul><hr><p>📉 <strong>4. 最少连接（least_conn）</strong></p><ul><li><strong>请求少，就给你分配点请求</strong>：Nginx会实时检查后端服务器的当前连接数，把新请求分配给当前连接数最少的服务器。（不是请求数，而是TCP连接数）</li><li><strong>适用场景</strong>：避免某台服务器过载，实现负载均衡。</li></ul><hr><p>🔗 <strong>5. URL哈希（url_hash）</strong></p><ul><li><strong>和IP哈希类似，但按URL分配</strong>：对请求的URL计算哈希值，<strong>相同URL的请求永远分配到同一台服务器</strong>。</li><li><strong>适用场景</strong>：利用缓存（比如同一张图片总在同一台服务器，缓存命中率高）。</li></ul><hr><p>⏱️ <strong>6. 公平（fair）</strong></p><ul><li><strong>哪个服务器处理时间短就多给点请求</strong>：Nginx会动态检查后端服务器的响应时间，优先把请求分配给响应快的服务器。</li><li><strong>适用场景</strong>：服务器性能差异大，且希望响应快的服务器多处理请求。</li></ul><hr><p>✅ 总结对比：</p><table><thead><tr><th>策略</th><th>原理概括</th><th>应用场景</th></tr></thead><tbody><tr><td>轮询</td><td>你一次我一次</td><td>服务器性能相近</td></tr><tr><td>权重</td><td>谁权重高谁多干活</td><td>服务器性能不同</td></tr><tr><td>IP哈希</td><td>同一个IP永远找同一台服务器</td><td>需要会话保持（如登录状态）</td></tr><tr><td>最少连接</td><td>谁闲谁干活</td><td>避免服务器过载</td></tr><tr><td>URL哈希</td><td>同一个URL永远找同一台服务器</td><td>提高缓存命中率（如图片、静态资源）</td></tr><tr><td>公平</td><td>谁快谁多干活</td><td>服务器响应速度差异大</td></tr></tbody></table><hr><h3 id="完善登录验证"><a href="#完善登录验证" class="headerlink" title="完善登录验证"></a>完善登录验证</h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250821164725124.png" alt="image-20250821164725124"></p><p>使用&#x2F;&#x2F;TODO注释可以标记代码文件位置 待办</p><p>使用md5加密方式来加密密码 单向(密码-&gt;字符串)</p><p>数据库密码就存储这个字符串 </p><p>要对比两个密码是否一样只能通过都加密然后对比字符串是否一样</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250821165019760.png" alt="image-20250821165019760"></p><p>asHex 16进制</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250821165349527.png" alt="image-20250821165349527"></p><p>如<code>123456</code>经过md5算法加密以后变成了<code>e10adc3949ba59abbe56e057f20f883e</code></p><p><code>yapi</code> 接口在线管理平台</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250821192556763.png" alt="image-20250821192556763"></p><p>但是推荐<code>Apifox </code>新建 导入<code>YaPi</code>拖拽<code>json</code>上传</p><h3 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h3><p>生成后端测试接口</p><p>加入增强版 knife4j</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250821194514360.png" alt="image-20250821194514360"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250821195620313.png" alt="image-20250821195620313"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250821200121047.png" alt="image-20250821200121047"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250821200743992.png" alt="image-20250821200743992"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250821201122816.png" alt="image-20250821201122816"></p><p>Knife4j的文档界面（<code>doc.html</code>）需要一些前端资源文件</p><p>这些文件都打包在Knife4j的jar包中，我们需要告诉Spring：”当有人访问 <code>doc.html</code> 时，请去jar包里的指定位置找这些文件</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250821201407530.png" alt="image-20250821201407530"></p><h3 id="Swagger常用注解"><a href="#Swagger常用注解" class="headerlink" title="Swagger常用注解"></a>Swagger常用注解</h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250821202202603.png" alt="image-20250821202202603"></p><p>这样生成的接口文档就有说明,可读性更高</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250821202347482.png" alt="image-20250821202347482"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250821202352648.png" alt="image-20250821202352648"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250821202417453.png" alt="image-20250821202417453"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250821202439413.png" alt="image-20250821202439413"></p><h2 id="项目开发-重点新学部分"><a href="#项目开发-重点新学部分" class="headerlink" title="项目开发(重点新学部分)"></a>项目开发(重点新学部分)</h2><h3 id="新增员工"><a href="#新增员工" class="headerlink" title="新增员工"></a>新增员工</h3><p>进入管理界面以后,可以对员工进行管理</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250821210103037.png" alt="image-20250821210103037"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250821210307860.png" alt="image-20250821210307860"></p><p>根据产品原型设计接口文档和数据库</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250821210430812.png" alt="image-20250821210430812"></p><h4 id="对象属性复制"><a href="#对象属性复制" class="headerlink" title="对象属性复制"></a>对象属性复制</h4><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250822091936975.png" alt="image-20250822091936975"></p><p>用<code>employeeDTO</code>封装传输数据</p><p>存在问题:</p><ul><li><p>username唯一,会抛出<code>sql</code>异常</p><p>解决方案: 创建一个全局异常处理器捕获,得到duplicate (运行时异常)</p></li><li><p>存<code>userid</code></p><p> 解决方案: <code>ThreadLocal </code>线程局部变量,线程隔离</p></li></ul><p>一次请求响应对应同一个线程</p><p>threadLocal是key 在map里面</p><h4 id="测试接口"><a href="#测试接口" class="headerlink" title="测试接口"></a>测试接口</h4><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250822104634889.png" alt="image-20250822104634889"></p><p>可以手动添加令牌token到参数,这样用测试工具就可以携带令牌了</p><h3 id="员工分页展示-查询"><a href="#员工分页展示-查询" class="headerlink" title="员工分页展示(查询)"></a>员工分页展示(查询)</h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250822104743468.png" alt="image-20250822104743468"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250822110253025.png" alt="image-20250822110253025"></p><p><code>PageHelper </code>基于<code>mybatis </code>的拦截器实现</p><p><code>PageHelper</code> 的底层靠拦截器<code> startpage</code>把<code>page</code>和<code>pageSize</code>放到<code>ThreadLocal</code>里面</p><h4 id="对于返回日期数据格式问题解决方案"><a href="#对于返回日期数据格式问题解决方案" class="headerlink" title="对于返回日期数据格式问题解决方案"></a>对于返回日期数据格式问题解决方案</h4><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250822134220376.png" alt="image-20250822134220376"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250822134329801.png" alt="image-20250822134329801"></p><h3 id="账号启用禁用状态"><a href="#账号启用禁用状态" class="headerlink" title="账号启用禁用状态"></a>账号启用禁用状态</h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250822134433482.png" alt="image-20250822134433482"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250822134441808.png" alt="image-20250822134441808"></p><p>点击启用 状态从禁用-&gt;启用 启用按钮-&gt;禁用按钮</p><p>反之同理</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250822134523937.png" alt="image-20250822134523937"></p><p>完全不用担心，这两行是MyBatis框架在Spring Boot项目中最经典的配置项。它们就像是给MyBatis这个“大厨”下的两道指令，告诉它“食材（SQL文件）”在哪，以及“菜名（实体类别名）”怎么简化。</p><p>我来给你用最通俗易懂的方式解释一下：</p><hr><ol><li><code>mapper-locations: classpath:mapper/*.xml</code></li></ol><p><strong>作用：</strong> <strong>告诉MyBatis，你写的SQL映射文件（Mapper XML文件）放在哪个目录下。</strong></p><ul><li><code>classpath:</code>：这是一个关键字，指的是你项目编译后的 <code>target/classes</code> 目录。通常，我们把资源文件放在项目的 <code>src/main/resources</code> 目录下，因为它们最终都会被复制到 <code>classpath</code> 下。</li><li><code>mapper/*.xml</code>：这是一个通配符路径。<code>mapper/</code> 表示在 <code>resources</code> 目录下有一个叫 <code>mapper</code> 的文件夹。<code>*.xml</code> 表示会加载这个文件夹下的<strong>所有</strong>以 <code>.xml</code> 结尾的文件。</li></ul><p><strong>举个例子：</strong><br>你的项目结构可能是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line">└── main/</span><br><span class="line">    ├── java/</span><br><span class="line">    │   └── com/example/YourApp.java</span><br><span class="line">    └── resources/</span><br><span class="line">        ├── application.yml       # 配置文件</span><br><span class="line">        └── mapper/               # 你配置的目录</span><br><span class="line">            ├── UserMapper.xml    # 用户相关的SQL</span><br><span class="line">            ├── OrderMapper.xml   # 订单相关的SQL</span><br><span class="line">            └── ProductMapper.xml # 商品相关的SQL</span><br></pre></td></tr></table></figure><p><strong>如果没有这个配置</strong>，MyBatis就不知道去哪里找这些 <code>.xml</code> 文件，你的SQL语句就无法被加载，程序就会报错。</p><p><strong>简单说：这条配置就是“SQL文件地址导航”。</strong></p><hr><ol start="2"><li><code>type-aliases-package: com.sky.entity</code></li></ol><p><strong>作用：</strong> <strong>为你的实体类设置一个简称（别名），这样在Mapper XML文件里就不用写全限定类名了。</strong></p><ul><li><code>com.sky.entity</code>：这是你的实体类（Entity）所在的包路径。MyBatis会自动扫描这个包下的所有Java类。</li></ul><p><strong>有什么好处？</strong><br>假设你有一个实体类，它的全限定名是：<code>com.sky.entity.User</code></p><p><strong>没有配置别名时</strong>，你在Mapper XML中必须写全名，非常冗长：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.sky.entity.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>配置了别名之后</strong>，MyBatis会默认使用<strong>类名</strong>（首字母大小写都行）作为别名(<strong>更准确的描述是：<code>type-aliases-package</code> 配置的作用是【开启自动别名扫描】，然后MyBatis会【自动地】为指定包下的所有类【注册一个别名】。</strong>)。所以你可以简写成：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者，如果你在类上使用了MyBatis的注解 <code>@Alias(&quot;MyUser&quot;)</code>，你甚至可以自定义别名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sky.entity;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.type.Alias;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Alias(&quot;MyUser&quot;)</span> <span class="comment">// 自定义别名</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;MyUser&quot;</span>&gt;</span> <span class="comment">&lt;!-- 使用自定义别名 --&gt;</span></span><br><span class="line">    SELECT * FROM user WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>简单说：这条配置就是“类名简化器”，为了写XML时更省事、更清晰。</strong></p><hr><p>总结与类比</p><table><thead><tr><th align="left">配置项</th><th align="left">通俗理解</th><th align="left">好处</th></tr></thead><tbody><tr><td align="left"><strong><code>mapper-locations</code></strong></td><td align="left"><strong>告诉MyBatis“菜谱（SQL文件）在哪”</strong></td><td align="left">让MyBatis找到你写的SQL语句。</td></tr><tr><td align="left"><strong><code>type-aliases-package</code></strong></td><td align="left"><strong>告诉MyBatis“菜名（实体类）的简称”</strong></td><td align="left">在XML中不用写又长又臭的全包名，使代码更简洁。</td></tr></tbody></table><p>所以，你配置文件里的这两行：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span>   <span class="comment"># 去resources/mapper/文件夹下找所有XML文件</span></span><br><span class="line"><span class="attr">type-aliases-package:</span> <span class="string">com.sky.entity</span>       <span class="comment"># com.sky.entity包下的类，在XML里可以用短名</span></span><br></pre></td></tr></table></figure><p>请求路径示例 &#x2F;admin&#x2F;employee&#x2F;1?id&#x3D;2</p><p>将id&#x3D;2的用户的状态设置为1</p><p>同用一个update持久层接口(复用 下面编辑员工信息也要用)</p><p>动态sql中</p><p><if test=''></if></p><p>这里的 <code>test</code> 表达式中判断的 <code>name</code> 和 <code>age</code>，就是 Mapper 接口方法传入的参数</p><p>员工信息编辑</p><p>1.员工信息回显</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250822164835329.png" alt="image-20250822164835329"></p><p>2.修改信息</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250822165726485.png" alt="image-20250822165726485"></p><h3 id="分类管理-cv"><a href="#分类管理-cv" class="headerlink" title="分类管理(cv)"></a>分类管理(cv)</h3><p>分类有两种类型一种菜品分类另一种套餐分类</p><p>分类名称是单一的</p><p>分类可以按照分类类型查询,按名字模糊查询</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250822233919154.png" alt="image-20250822233919154"></p><p>分类可以设置状态启用禁用</p><p>新增分类时候默认禁用,因为该分类下还没有菜品,不要显示在前端</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250822232649533.png" alt="image-20250822232649533"></p><p>分类根据sort排序字段的数字大小排序</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250822233858919.png" alt="image-20250822233858919"></p><p>删除分类时:</p><p>菜品分类要注意是否该分类已经关联菜品,套餐分类是否关联套餐</p><p>list 根据分类类型type查询</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250823092611780.png" alt="image-20250823092611780"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250823092526366.png" alt="image-20250823092526366"></p><p>公共字段填充(更新信息)</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250823093157026.png" alt="image-20250823093157026"></p><p>自定义注解</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250823134829394.png" alt="image-20250823134829394"></p><p>定义自动填充切面</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250823135139595.png" alt="image-20250823135139595"></p><p>通知</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250823135401976.png" alt="image-20250823135401976"></p><p>先获取注解上的操作类型</p><p>然后获得该方法上的实体对象</p><p>根据操作类型设置对象公共字段(利用反射 先从obj获得方法对象) </p><p>然后用方法对象设置属性</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250823135544349.png" alt="image-20250823135544349"></p><p>标记切入点</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250823135613987.png" alt="image-20250823135613987"></p><h3 id="菜品管理"><a href="#菜品管理" class="headerlink" title="菜品管理"></a>菜品管理</h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250823144014710.png" alt="image-20250823144014710"></p><p>逻辑外键: 不在数据库设置物理外键, 在程序中设计 由程序员来维护表间关系</p><p>加入口味</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250823222033844.png" alt="image-20250823222033844"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250824094450142.png" alt="image-20250824094450142"></p><p>value后面用foreach遍历填值</p><p>()用逗号分隔</p><p>即insert int 表() values(),(),()….</p><p><strong>挖个坑 分类状态和菜品状态 以及套餐状态 分类启用停用会影响菜品和套餐么</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250824150031517.png" alt="image-20250824150031517"></p><p>删除菜品要考虑的事情</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250824152833218.png" alt="image-20250824152833218"></p><p>解决List<long>和List<Integer>复用一个方法的问题</p><h3 id="店铺状态管理"><a href="#店铺状态管理" class="headerlink" title="店铺状态管理"></a>店铺状态管理</h3><p>(我的理解是 营业状态是在程序允许时需要修改且管理 不需要放到数据库)</p><p>存储到redis中 key-value  </p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250825210719646.png" alt="image-20250825210719646"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250825223253361.png" alt="image-20250825223253361"></p><h3 id="实现swagger接口分类展示"><a href="#实现swagger接口分类展示" class="headerlink" title="实现swagger接口分类展示"></a>实现swagger接口分类展示</h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250825224011783.png" alt="image-20250825224011783"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250825224035204.png" alt="image-20250825224035204"></p><h3 id="HTTPClient"><a href="#HTTPClient" class="headerlink" title="HTTPClient"></a><code>HTTPClient</code></h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250825225936429.png" alt="image-20250825225936429"></p><p>java程序中发送请求的一个工具</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250825230047881.png" alt="image-20250825230047881"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250825230207522.png" alt="image-20250825230207522"></p><p>在前面使用aliyunOss已经引入了这个依赖</p><h4 id="发送GET请求"><a href="#发送GET请求" class="headerlink" title="发送GET请求"></a>发送GET请求</h4><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250825232630894.png" alt="image-20250825232630894"></p><h4 id="发送POST请求"><a href="#发送POST请求" class="headerlink" title="发送POST请求"></a>发送POST请求</h4><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250825233707508.png" alt="image-20250825233707508"></p><p>请求体用String格式的请求体,<strong>可以用简单的字符串</strong></p><p>但是手动填写很麻烦,可以用<code>fastjson</code>(<code>alibaba</code>)提供的工具来构建一个<code>json对象</code></p><p>设置一下数据格式<code>UTF-8</code> 并且设置请求体是<code>json</code></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250825233955455.png" alt="image-20250825233955455"></p><p>解析结果</p><h2 id="微信小程序端开发"><a href="#微信小程序端开发" class="headerlink" title="微信小程序端开发"></a>微信小程序端开发</h2><table><thead><tr><th>小程序<code>AppID</code></th><th>wxef2b2811faa33ce3</th></tr></thead><tbody><tr><td><code>AppSecret</code></td><td>ca051ae585dd328e4c9d2ba9c2cb8545</td></tr></tbody></table><h3 id="小程序开发代码基本结构"><a href="#小程序开发代码基本结构" class="headerlink" title="小程序开发代码基本结构"></a>小程序开发代码基本结构</h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250826095646578.png" alt="image-20250826095646578"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250826103833877.png" alt="image-20250826103833877"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250826103855959.png" alt="image-20250826103855959"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250826103810515.png" alt="image-20250826103810515"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250826103842124.png" alt="image-20250826103842124"></p><p>发送请求</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250826104202650.png" alt="image-20250826104202650"></p><h3 id="小程序微信登录"><a href="#小程序微信登录" class="headerlink" title="小程序微信登录"></a>小程序微信登录</h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250826131601942.png" alt="image-20250826131601942"></p><p>在js调用<code>wx.login()</code>方法会自动返回一个授权码code(只能使用一次,使用过后就会失效)</p><p>然后在前端向服务端发送请求,携带这个code</p><p>由服务端向微信服务端发送请求(<code>appid+appsecret+code</code>)</p><p>微信服务端返回<code>openid</code>微信账号唯一标识  以及其他一些信息</p><p>openid用来查询服务端有没有该用户,没有就创建新用户存数据库,有的话直接返回user对象</p><p>服务端向小程序端返回登录信息(<code>userid openid jwt令牌</code>)</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250826132001199.png" alt="image-20250826132001199"> </p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250826132939137.png" alt="image-20250826132939137"></p><p>这个登录允许之后就会获得用户名称头像,需要在此完成自动登录校验</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250826133145225.png" alt="image-20250826133145225"></p><p>用户端用户模块登录接口</p><p>携带code</p><p>返回微信服务端用户唯一标识<code>openid</code> 服务端用户唯一标识 jwt登录校验令牌</p><h3 id="店铺商品浏览"><a href="#店铺商品浏览" class="headerlink" title="店铺商品浏览"></a>店铺商品浏览</h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250826213203087.png" alt="image-20250826213203087"></p><p>接口设计</p><p>侧边栏展示的是分类</p><p>所以查询分类GET &#x2F;user&#x2F;category&#x2F;list?type&#x3D;(1,2) 可选type</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250826213414653.png" alt="image-20250826213414653"></p><p>然后右侧菜品 根据分类id查询菜品</p><p>GET &#x2F;user&#x2F;dish&#x2F;list?categoryId&#x3D;</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250826213515874.png" alt="image-20250826213515874"></p><p>这里直接把菜品的口味也查了 对应数据可以在选择规格弹窗展示,如果没有口味就只显示一个加号</p><p>根据套餐分类id查询套餐 </p><p>get &#x2F;user&#x2F;setmeal&#x2F;list?categoryId&#x3D;</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250826214741489.png" alt="image-20250826214741489"></p><p>根据套餐id查询菜品setmeal_dish</p><p>&#x2F;user&#x2F;setmeal&#x2F;dish&#x2F;{id}</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250826214820479.png" alt="image-20250826214820479"></p><p>商品展示缓存</p><p>如果用户端频繁切换查看商品,就要频繁查询数据库,对数据库压力较大,所以可以把商品缓存起来到redis中,有改动才把缓存更新(删除,添加)</p><p><strong>例如菜品浏览</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250827110849983.png" alt="image-20250827110849983"></p><p>从redis中尝试拿到缓存数据,没有才走数据库(并存放到redis)</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250827110814202.png" alt="image-20250827110814202"></p><p>删除(更新) 原则:改动哪些数据就对应更新哪个缓存</p><p>如果精准添加分类下的菜品,那么只需要更新那一个缓存</p><p>如果影响涉及多个缓存,批量删除菜品(还要根据id查cateoryId) </p><p>或者更新菜品状态(也要查categoryId)</p><p>那么可以简单清除所有缓存</p><h3 id="Spring-cache"><a href="#Spring-cache" class="headerlink" title="Spring cache"></a>Spring cache</h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250827155505591.png" alt="image-20250827155505591"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250827155630902.png" alt="image-20250827155630902"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250827164445287.png" alt="image-20250827164445287"></p><p>redis key的值对应cacheNames::key</p><p>如果开了allEntries&#x3D;true则代表cacheNames层级下的所有key</p><p>茴香豆的写法 spring sp EL</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250827164718668.png" alt="image-20250827164718668"></p><p>处理缓存基于代理对象,调用方法得到返回值基于反射</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250827165035720.png" alt="image-20250827165035720"></p><p>​</p><h3 id="微信支付"><a href="#微信支付" class="headerlink" title="微信支付"></a>微信支付</h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250828213101883.png" alt="image-20250828213101883"></p><p>​</p><p>小程下单生成订单号,然后点击结算申请微信支付 后端调微信支付服务接口 设置参数,(订单号,支付成功回调地址…必要参数) 返回<strong>支付交易标识(<strong>预支付,先告诉微信等下要支付了,备案) 后端对标识处理 签名加密 (传输安全) 响应给小程序,用户确认支付,直接调用微信支付服务接口 微信后台给小程序返回结果 并给</strong>用户后端回调推送支付结果</strong> 后端更新支付状态</p><p>要保证数据安全</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250829101219503.png" alt="image-20250829101219503"></p><p>进行加密解密签名,需要提供一些证书</p><p>微信后台调用商户系统需要将ip暴露出去(公网) 内网穿透</p><p>内网穿透工具:cpolar</p><p>推送支付结果之后同样需要响应 (微信持续推送,收到确认信号才会停止)</p><p>流程:</p><p>配置参数</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250830162205120.png" alt="image-20250830162205120"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250830161350264.png" alt="image-20250830161350264"></p><p>首先小程序申请微信支付</p><p>商户后台调用微信支付接口</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250830161426472.png" alt="image-20250830161426472"></p><p>调用jsapi接口 发送请求</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250830161552127.png" alt="image-20250830161552127"></p><p>对返回的预支付标识进行加密签名</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250830161727263.png" alt="image-20250830161727263"></p><p>给小程序返回参数</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250830161802055.png" alt="image-20250830161802055"></p><p>小程序用户确认支付,直接调用微信支付服务接口 </p><p>微信支付后台调用paysuccess接口 </p><p>​<img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250830162520388.png" alt="image-20250830162520388"></p><h3 id="订单历史"><a href="#订单历史" class="headerlink" title="订单历史"></a>订单历史</h3><p><strong>订单分页查询(一个订单对多个订单详细) 前后端返回数据正常,但是显示异常?</strong></p><h3 id="取消订单"><a href="#取消订单" class="headerlink" title="取消订单"></a>取消订单</h3><p>主要是业务逻辑比以前的复杂了,传来一个订单id</p><p>然后首先是把整个订单数据查询回来(一个是判断订单是否存在,另一个是判断订单状态)</p><p>订单是否存在</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250830162953679.png" alt="image-20250830162953679"></p><p>订单状态: 如果订单已接单(客户取消订单需要联系商家,由商家操作)</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250830163046617.png" alt="image-20250830163046617"></p><p>此外 如果未接单但已付款 就要设置支付状态为退款(并退款 这里个人不能真实接入微信支付所以只改了支付状态)</p><p>取消订单后,设置取消原因 订单状态设置为已取消 设置取消时间</p><p>最后更新订单数据</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250830163238956.png" alt="image-20250830163238956"></p><h3 id="再来一单"><a href="#再来一单" class="headerlink" title="再来一单"></a>再来一单</h3><p>由于生成订单后购物车会被清空,再来一单需要把订单中的商品重新加入购物车,因此,根据订单的id可以查询出订单详细,就能知道订单中有哪些商品,这些商品就需要重新加入购物车</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250830163603238.png" alt="image-20250830163603238"></p><p>找到订单详细,之前我是实现了一个一对多的返回订单数据视图 (OrderVO)</p><p>从这里在获得详细</p><p>然后用stream流将每一个订单详细(一个订单详细就是对应一个商品 (购物车shoppingCart会被清 所以是存到订单详细))</p><p>映射成商品 然后收集变成购物车商品集合然后再批量插入 </p><p>查询具体订单时,需要返回商品信息的字符串,需要拼接</p><p>​<img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250831120312195.png" alt="image-20250831120312195"></p><p>思路是遍历每一个orderVO中的订单详细 得到名称数量 拼接成字符串然后返回字符串List</p><p>再把字符串List拼接到一块 <code>String.join()</code>就可以把订单的具体商品信息拼在一起了</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250831175915955.png" alt="image-20250831175915955"></p><h3 id="百度地图定位api"><a href="#百度地图定位api" class="headerlink" title="百度地图定位api"></a>百度地图定位api</h3><p>注册应用</p><p>获得ak密钥</p><p><code>AK:X5mW31CzC3gUSBLD6hTrzX4iPjAF1t9O</code></p><p>配置参数(现在商铺地址现在还没有管理  是手动配置 可以完善用实时定位)</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250831181805893.png" alt="image-20250831181805893"></p><p>Get请求 通过两个请求参数 <img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250831181844443.png" alt="image-20250831181844443"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250831181725172.png" alt="image-20250831181725172"></p><p>构造并发送请求</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250831181955895.png" alt="image-20250831181955895"></p><p>解析结果 拼接经纬度字符串 用户地址同理</p><p>调用路线规划api</p><p>构造并请求get</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250831182718328.png" alt="image-20250831182718328"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250831182700258.png" alt="image-20250831182700258"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250831182617806.png" alt="image-20250831182617806"></p><p>解析结果</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250831182744599.png" alt="image-20250831182744599"></p><p>嵌套</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250831182807639.png" alt="image-20250831182807639"></p><p>从返回的json中解析出嵌套json <code>result</code></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250831183418787.png" alt="image-20250831183418787"></p><p>其中取出”routes” 这是json数组 (代表路线)</p><p>取出其中第一条路线的distance</p><p>最后判断距离</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250831183916190.png" alt="image-20250831183916190"></p><h3 id="SpringTask"><a href="#SpringTask" class="headerlink" title="SpringTask"></a>SpringTask</h3><p>执行定时任务的一个任务调度框架</p><p>像闹钟一样,到指定时间就触发任务</p><h4 id="cron表达式"><a href="#cron表达式" class="headerlink" title="cron表达式"></a>cron表达式</h4><p>字符串,指定触发时间</p><p>秒 分 时 日 月 星期几 年</p><p>日和星期几不同时存在,其中一个用?代替</p><p>比如2025年8月31号上午11点整</p><p>0 0 11 31 8 ? 2025</p><p>中间空格隔开</p><p>有cron表达式生成器</p><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250831232959186.png" alt="image-20250831232959186"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250831233819164.png" alt="image-20250831233819164"></p><h3 id="定时处理的需求分析"><a href="#定时处理的需求分析" class="headerlink" title="定时处理的需求分析"></a>定时处理的需求分析</h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250831234109833.png" alt="image-20250831234109833"></p><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>基于TCP的一种新的网络协议</p><p>原来的http 请求响应模型</p><p>是 发送请求 返回响应 单向 短连接(连接建立在发送请求到返回响应间) </p><p>单向是只能由web端像服务端发送请求然后服务端接到请求才会返回响应数据</p><p>服务端不能主动向web端发送</p><p>websocket 双向数据传输</p><p>并且长连接(只要进行一次握手以后就可以进行双向通信)</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250901143924698.png" alt="image-20250901143924698"></p><p>​</p><p>应用场景:</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250901143944483.png" alt="image-20250901143944483"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250901143953236.png" alt="image-20250901143953236"></p><p>示例使用步骤:</p><p>web端作为websocket客户端</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250901151016427.png" alt="image-20250901151016427"></p><p>然后导入Websocket依赖 </p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250901151104993.png" alt="image-20250901151104993"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250901151358971.png" alt="image-20250901151358971"></p><p>客户端回调方法</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250901151408536.png" alt="image-20250901151408536"></p><p>服务端组件</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250901152610503.png" alt="image-20250901152610503"></p><p>配置类</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250901153250144.png" alt="image-20250901153250144"></p><h3 id="消息提示-来单-催单"><a href="#消息提示-来单-催单" class="headerlink" title="消息提示(来单,催单)"></a>消息提示(来单,催单)</h3><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250901153849210.png" alt="image-20250901153849210"></p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250901155741049.png" alt="image-20250901155741049"></p><p>客户端和服务端进行websocket连接</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250901170011685.png" alt="image-20250901170011685"></p><p>约定好服务端给客户端响应json格式的字符串</p><p>用map转json字符串然后再发送</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250901170102910.png" alt="image-20250901170102910"></p><p>   服务端底层是调用了sendText方法 遍历会话集合里的map取出连接的session</p><h3 id="Apache-POI"><a href="#Apache-POI" class="headerlink" title="Apache POI"></a>Apache POI</h3><p>操作MS Office 常见的比如EXCEL表格</p><p>在java中对Excel表格进行读写操作</p><p>使用步骤:</p><p>导入依赖</p><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250903150515527.png" alt="image-20250903150515527"></p><h4 id="写"><a href="#写" class="headerlink" title="写"></a>写</h4><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250903150750888.png" alt="image-20250903150750888"></p><h4 id="读"><a href="#读" class="headerlink" title="读"></a>读</h4><p><img src="https://cdn.jsdelivr.net/gh/yihgyi/picgo/img/image-20250903151037785.png" alt="image-20250903151037785"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用hexo+github快速搭建自己的博客</title>
      <link href="/2025/09/03/%E4%BD%BF%E7%94%A8hexo-github%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
      <url>/2025/09/03/%E4%BD%BF%E7%94%A8hexo-github%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="前置条件-没学也没事，按照提示步骤安装好这两个东西就可以了"><a href="#前置条件-没学也没事，按照提示步骤安装好这两个东西就可以了" class="headerlink" title="前置条件:(没学也没事，按照提示步骤安装好这两个东西就可以了)"></a>前置条件:(没学也没事，按照提示步骤安装好这两个东西就可以了)</h2><p>学javaweb用过的<code>Node.js</code> , <code>git</code></p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤:"></a>使用步骤:</h2><h3 id="1-安装hexo"><a href="#1-安装hexo" class="headerlink" title="1.安装hexo"></a>1.安装hexo</h3><p>在你的博客网址管理的目录(不止一个博客网站 <strong>我的博客-博客1</strong> 我的博客-博客2 …)</p><p>即我的博客这个目录 打开终端(可能需要管理员权限 这里最好直接打开管理员模式运行的cmd)</p><p>进入到这个目录 cd xxxx</p><p>然后输入<code>npm install -g hexo-cli</code></p><p>来安装hexo</p><h3 id="2-我安装的主题是butterfly"><a href="#2-我安装的主题是butterfly" class="headerlink" title="2.我安装的主题是butterfly"></a>2.我安装的主题是butterfly</h3><p>然后我发现这个butterfly提供了一个butterfly-cli客户端</p><p>可以快速搭建管理butterfly项目 就像vue脚手架一样哈哈</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-butterfly-cli -g</span><br></pre></td></tr></table></figure><p>然后输入<code>butterfly-cli install 博客名</code></p><p>并选用自定义配置hexo模板</p><p>然后就可以快速搭建一个butterfly主题的博客了</p><p> 如果装别的主题 装到themes目录下或者会被装到node_modules里面</p><p> 然后修改hexo框架的配置文件<code> _config.yml</code> </p><p>​     把<code>theme</code>配置项修改为主题名称</p><h3 id="3-部署到github-可以供别人访问"><a href="#3-部署到github-可以供别人访问" class="headerlink" title="3.部署到github 可以供别人访问"></a>3.部署到github 可以供别人访问</h3><p>(在git教程中配置过 git config –global的userame以及email)</p><ul><li>拥有一个github账号</li><li>创建一个仓库(仓库名 username.github.io 开启README) #username 就是github的用户名</li><li>使用HTTPS那个仓库链接&#x2F;自己配置SSH 添加到Github上面(配置方法git教程中)</li></ul><p>最终配置:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">   <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">   <span class="attr">repo:</span> <span class="string">git@github.com:yihgyi/yihgyi.github.io.git</span> <span class="comment">#username是你的账号名，username.github.io是你的仓库名</span></span><br><span class="line">   <span class="attr">branch:</span> <span class="string">main</span> <span class="comment">#现在github默认是main分支</span></span><br></pre></td></tr></table></figure><p>配置完以后:</p><p>进入你的博客目录 (我的博客-博客1)</p><p>就是<strong>博客1</strong>这个目录</p><p>别进错目录了哈哈</p><p>然后安装hexo的部署插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>这样就可以推到仓库去了</p><p>然后执行标准一套命令hexo clean hexo g(generate生成) hexo d(deploy部署) 可以试着hexo server 可以部署到本地4000端口访问</p><p>这时候已经将public的内容(博客的静态页面)部署到github上面了  </p><p>别人访问只需要输入你的github仓库名称即 username.github.io即可~</p><h3 id="4-可以用git对博客源码进行版本控制"><a href="#4-可以用git对博客源码进行版本控制" class="headerlink" title="4.可以用git对博客源码进行版本控制"></a>4.可以用git对博客源码进行版本控制</h3><h3 id="5-发布文章"><a href="#5-发布文章" class="headerlink" title="5.发布文章"></a>5.发布文章</h3><p>只需要输入<code>hexo n &quot;文章标题&quot;</code>即可 然后可以修改md文件 或者手动添加md文件 但是开头有规定格式</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/09/03/hello-world/"/>
      <url>/2025/09/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
